{"ast":null,"code":"export function findMovableSquaresInDirection({\n  startingSquare,\n  getNextSquareFn,\n  mapObj\n}) {\n  console.log(getNextSquareFn);\n  let currentlyCheckedSquare = startingSquare;\n  let movableSquares = [];\n  const player = mapObj[startingSquare].player;\n\n  const isSquareInsideBoard = square => Number(square) >= 0 && Number(square) <= 77;\n\n  while (isSquareInsideBoard(currentlyCheckedSquare)) {\n    // advance one square each iteration (note that the starting square is not a square you can move into)\n    console.log(getNextSquareFn);\n    currentlyCheckedSquare = getNextSquareFn(currentlyCheckedSquare);\n    const squareContent = mapObj[currentlyCheckedSquare]; // if square is empty, add it as movable and advance one square\n\n    if (!squareContent) {\n      movableSquares.push(currentlyCheckedSquare);\n    } // if last square is occupied by opponent's piece, the square is movable as the piece can be taken\n    else if (squareContent.player !== player) {\n        movableSquares.push(startingSquare);\n        break;\n      } // Square is not empty, nor taken by an opponent's piece\n      else {\n          break;\n        }\n  }\n\n  return movableSquares;\n}","map":{"version":3,"sources":["/Users/mac/Chess/src/findMovableSquares.js"],"names":["findMovableSquaresInDirection","startingSquare","getNextSquareFn","mapObj","console","log","currentlyCheckedSquare","movableSquares","player","isSquareInsideBoard","square","Number","squareContent","push"],"mappings":"AAAA,OAAO,SAASA,6BAAT,CAAuC;AAC5CC,EAAAA,cAD4C;AAE5CC,EAAAA,eAF4C;AAG5CC,EAAAA;AAH4C,CAAvC,EAIJ;AACDC,EAAAA,OAAO,CAACC,GAAR,CAAYH,eAAZ;AACA,MAAII,sBAAsB,GAAGL,cAA7B;AACA,MAAIM,cAAc,GAAG,EAArB;AACA,QAAMC,MAAM,GAAGL,MAAM,CAACF,cAAD,CAAN,CAAuBO,MAAtC;;AACA,QAAMC,mBAAmB,GAAIC,MAAD,IAC1BC,MAAM,CAACD,MAAD,CAAN,IAAkB,CAAlB,IAAuBC,MAAM,CAACD,MAAD,CAAN,IAAkB,EAD3C;;AAGA,SAAOD,mBAAmB,CAACH,sBAAD,CAA1B,EAAoD;AAClD;AACAF,IAAAA,OAAO,CAACC,GAAR,CAAYH,eAAZ;AACAI,IAAAA,sBAAsB,GAAGJ,eAAe,CAACI,sBAAD,CAAxC;AACA,UAAMM,aAAa,GAAGT,MAAM,CAACG,sBAAD,CAA5B,CAJkD,CAKlD;;AACA,QAAI,CAACM,aAAL,EAAoB;AAClBL,MAAAA,cAAc,CAACM,IAAf,CAAoBP,sBAApB;AACD,KAFD,CAGA;AAHA,SAIK,IAAIM,aAAa,CAACJ,MAAd,KAAyBA,MAA7B,EAAqC;AACxCD,QAAAA,cAAc,CAACM,IAAf,CAAoBZ,cAApB;AACA;AACD,OAHI,CAIL;AAJK,WAKA;AACH;AACD;AACF;;AAED,SAAOM,cAAP;AACD","sourcesContent":["export function findMovableSquaresInDirection({\n  startingSquare,\n  getNextSquareFn,\n  mapObj,\n}) {\n  console.log(getNextSquareFn);\n  let currentlyCheckedSquare = startingSquare;\n  let movableSquares = [];\n  const player = mapObj[startingSquare].player;\n  const isSquareInsideBoard = (square) =>\n    Number(square) >= 0 && Number(square) <= 77;\n\n  while (isSquareInsideBoard(currentlyCheckedSquare)) {\n    // advance one square each iteration (note that the starting square is not a square you can move into)\n    console.log(getNextSquareFn);\n    currentlyCheckedSquare = getNextSquareFn(currentlyCheckedSquare);\n    const squareContent = mapObj[currentlyCheckedSquare];\n    // if square is empty, add it as movable and advance one square\n    if (!squareContent) {\n      movableSquares.push(currentlyCheckedSquare);\n    }\n    // if last square is occupied by opponent's piece, the square is movable as the piece can be taken\n    else if (squareContent.player !== player) {\n      movableSquares.push(startingSquare);\n      break;\n    }\n    // Square is not empty, nor taken by an opponent's piece\n    else {\n      break;\n    }\n  }\n\n  return movableSquares;\n}\n"]},"metadata":{},"sourceType":"module"}