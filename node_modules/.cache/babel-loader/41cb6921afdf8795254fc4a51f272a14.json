{"ast":null,"code":"export function findMovableSquaresInDirection({\n  startingSquare,\n  getNextSqureFn,\n  mapObj\n}) {\n  console.log(getNextSqureFn);\n  console.log(startingSquare);\n  let currentlyCheckedSquare = startingSquare;\n  let movableSquares = [];\n  const player = mapObj[startingSquare].player;\n\n  const isSquareInsideBoard = square => Number(square) >= 0 && Number(square) <= 77;\n\n  while (isSquareInsideBoard(currentlyCheckedSquare)) {\n    // advance one square each iteration (note that the starting square is not a square you can move into)\n    currentlyCheckedSquare = getNextSqureFn(currentlyCheckedSquare);\n    const squareContent = mapObj[currentlyCheckedSquare]; // if square is empty, add it as movable and advance one square\n\n    if (squareContent.type === \"empty\") {\n      movableSquares.push(currentlyCheckedSquare);\n    } // if last square is occupied by opponent's piece, the square is movable as the piece can be taken\n    else if (squareContent.player !== player) {\n        movableSquares.push(startingSquare);\n        break;\n      } // Square is not empty, nor taken by an opponent's piece\n      else {\n          break;\n        }\n  }\n\n  return movableSquares;\n}","map":{"version":3,"sources":["/Users/mac/Chess/src/findMovableSquares.js"],"names":["findMovableSquaresInDirection","startingSquare","getNextSqureFn","mapObj","console","log","currentlyCheckedSquare","movableSquares","player","isSquareInsideBoard","square","Number","squareContent","type","push"],"mappings":"AAAA,OAAO,SAASA,6BAAT,CAAuC;AAC5CC,EAAAA,cAD4C;AAE5CC,EAAAA,cAF4C;AAG5CC,EAAAA;AAH4C,CAAvC,EAIJ;AACDC,EAAAA,OAAO,CAACC,GAAR,CAAYH,cAAZ;AACAE,EAAAA,OAAO,CAACC,GAAR,CAAYJ,cAAZ;AACA,MAAIK,sBAAsB,GAAGL,cAA7B;AACA,MAAIM,cAAc,GAAG,EAArB;AACA,QAAMC,MAAM,GAAGL,MAAM,CAACF,cAAD,CAAN,CAAuBO,MAAtC;;AACA,QAAMC,mBAAmB,GAAIC,MAAD,IAC1BC,MAAM,CAACD,MAAD,CAAN,IAAkB,CAAlB,IAAuBC,MAAM,CAACD,MAAD,CAAN,IAAkB,EAD3C;;AAGA,SAAOD,mBAAmB,CAACH,sBAAD,CAA1B,EAAoD;AAClD;AACAA,IAAAA,sBAAsB,GAAGJ,cAAc,CAACI,sBAAD,CAAvC;AACA,UAAMM,aAAa,GAAGT,MAAM,CAACG,sBAAD,CAA5B,CAHkD,CAIlD;;AACA,QAAIM,aAAa,CAACC,IAAd,KAAuB,OAA3B,EAAoC;AAClCN,MAAAA,cAAc,CAACO,IAAf,CAAoBR,sBAApB;AACD,KAFD,CAGA;AAHA,SAIK,IAAIM,aAAa,CAACJ,MAAd,KAAyBA,MAA7B,EAAqC;AACxCD,QAAAA,cAAc,CAACO,IAAf,CAAoBb,cAApB;AACA;AACD,OAHI,CAIL;AAJK,WAKA;AACH;AACD;AACF;;AAED,SAAOM,cAAP;AACD","sourcesContent":["export function findMovableSquaresInDirection({\n  startingSquare,\n  getNextSqureFn,\n  mapObj,\n}) {\n  console.log(getNextSqureFn);\n  console.log(startingSquare);\n  let currentlyCheckedSquare = startingSquare;\n  let movableSquares = [];\n  const player = mapObj[startingSquare].player;\n  const isSquareInsideBoard = (square) =>\n    Number(square) >= 0 && Number(square) <= 77;\n\n  while (isSquareInsideBoard(currentlyCheckedSquare)) {\n    // advance one square each iteration (note that the starting square is not a square you can move into)\n    currentlyCheckedSquare = getNextSqureFn(currentlyCheckedSquare);\n    const squareContent = mapObj[currentlyCheckedSquare];\n    // if square is empty, add it as movable and advance one square\n    if (squareContent.type === \"empty\") {\n      movableSquares.push(currentlyCheckedSquare);\n    }\n    // if last square is occupied by opponent's piece, the square is movable as the piece can be taken\n    else if (squareContent.player !== player) {\n      movableSquares.push(startingSquare);\n      break;\n    }\n    // Square is not empty, nor taken by an opponent's piece\n    else {\n      break;\n    }\n  }\n\n  return movableSquares;\n}\n"]},"metadata":{},"sourceType":"module"}