{"ast":null,"code":"var _jsxFileName = \"/Users/mac/Chess/src/App.js\";\nimport React, { useState, useEffect } from \"react\"; // import logo from \"./logo.svg\";\n\nimport \"./App.css\";\nimport Square from \"./Square\";\nimport { findMovableSquaresInDirection } from \"./findMovableSquares\";\nconst mapObj = {\n  //database of the board\n  \"00\": {\n    type: \"rook\",\n    player: false\n  },\n  \"01\": {\n    type: \"knight\",\n    player: false\n  },\n  \"02\": {\n    type: \"bishop\",\n    player: false\n  },\n  \"03\": {\n    type: \"king\",\n    player: false\n  },\n  \"04\": {\n    type: \"queen\",\n    player: false\n  },\n  \"05\": {\n    type: \"bishop\",\n    player: false\n  },\n  \"06\": {\n    type: \"knight\",\n    player: false\n  },\n  \"07\": {\n    type: \"rook\",\n    player: false\n  },\n  10: {\n    type: \"pawn\",\n    player: false\n  },\n  11: {\n    type: \"pawn\",\n    player: false\n  },\n  12: {\n    type: \"pawn\",\n    player: false\n  },\n  13: {\n    type: \"pawn\",\n    player: false\n  },\n  14: {\n    type: \"pawn\",\n    player: false\n  },\n  15: {\n    type: \"pawn\",\n    player: false\n  },\n  16: {\n    type: \"pawn\",\n    player: false\n  },\n  17: {\n    type: \"pawn\",\n    player: false\n  },\n  60: {\n    type: \"pawn\",\n    player: true\n  },\n  61: {\n    type: \"pawn\",\n    player: true\n  },\n  62: {\n    type: \"pawn\",\n    player: true\n  },\n  63: {\n    type: \"pawn\",\n    player: true\n  },\n  64: {\n    type: \"pawn\",\n    player: true\n  },\n  65: {\n    type: \"pawn\",\n    player: true\n  },\n  66: {\n    type: \"pawn\",\n    player: true\n  },\n  67: {\n    type: \"pawn\",\n    player: true\n  },\n  70: {\n    type: \"rook\",\n    player: true\n  },\n  71: {\n    type: \"knight\",\n    player: true\n  },\n  72: {\n    type: \"bishop\",\n    player: true\n  },\n  73: {\n    type: \"king\",\n    player: true\n  },\n  74: {\n    type: \"queen\",\n    player: true\n  },\n  75: {\n    type: \"bishop\",\n    player: true\n  },\n  76: {\n    type: \"knight\",\n    player: true\n  },\n  77: {\n    type: \"rook\",\n    player: true\n  }\n};\n\nconst Board = () => {\n  const [count, setCount] = useState(0);\n  const [fromSquare, setFromSquare] = useState();\n  const [player, setPlayer] = useState(true);\n  const [check, setCheck] = useState(false);\n  const [chosen, setChosen] = useState();\n  let printCheckOutside;\n  let printPlayerOutside;\n\n  const printCheck = check => {\n    check === false ? printCheckOutside = \"no check at this point\" : printCheckOutside = \"check, please protect your King\";\n  };\n\n  const printPlayer = player => {\n    player === true ? printPlayerOutside = \"white player's turn\" : printPlayerOutside = \"blue player's turn\";\n  };\n\n  printCheck(check);\n  printPlayer(player);\n\n  const moveInvoke = (moveFrom, moveTo) => {\n    // the actual movePiece\n    movePiece(moveFrom, moveTo);\n  }; // checking if theres a check in play\n\n\n  const findKing = startingSquare => {\n    // here we find the king's key (location)\n    const entries = Object.entries(mapObj);\n\n    for (let i = 0; i <= entries.length - 1; i++) {\n      let kingIndex;\n\n      if (entries[i][1].type === \"king\") {\n        if (entries[i][1].player !== mapObj[startingSquare].player) {\n          kingIndex = entries[i][0];\n          console.log(\"insideFindKing:\", kingIndex);\n          return kingIndex;\n        }\n      }\n    }\n  };\n\n  const movePiece = (fromSquare, toSquare) => {\n    const movingContent = () => {\n      // here we will move the actual piece from one sqaure to another.\n      // 1. mapObj[toSquare] = mapObj[fromSquare] to the obj\n      // 2. delete the property whose key is \"fromSquare\" from mapObj\n      // const path = getTheFigurePath(fromSquare, toSquare);\n      if (check === true) {\n        return;\n      } // if (!checkPath(path)) return;\n\n\n      mapObj[toSquare] = mapObj[fromSquare];\n      delete mapObj[fromSquare];\n      setPlayer(!player);\n    };\n\n    if (player === true) {\n      if (mapObj[fromSquare].player === true) {\n        movingContent();\n      }\n    } else if (player === false) {\n      if (mapObj[fromSquare].player === false) {\n        movingContent();\n      }\n    }\n  }; // useEffect(() => {\n  //   console.log(\"inEffect\", fromSquare, toSquare);\n  //   if (fromSquare && toSquare) {\n  //     movePiece(fromSquare, toSquare);\n  //     // setToSquare();\n  //   }\n  // }, [fromSquare, toSquare]);\n\n\n  const parseToNumber = square => {\n    const [row, col] = square.split(\"\");\n    return [parseInt(row), parseInt(col)];\n  };\n\n  const addPossibleCellToPath = (fromSquare, nextPossibleRow, nextPossibleCol, nextPossibleMoves) => {\n    const player = mapObj[fromSquare].player;\n    const typeOfSquare = mapObj[fromSquare].type;\n    const nextPossibleCell = nextPossibleRow.toString() + nextPossibleCol.toString(); // if (!typeOfSquare !== \"knight\") {\n    //   console.log(nextPossibleCell);\n    //   if (mapObj[nextPossibleCell].player !== player) {\n    //     // figure that is not a knight cant jump over figures\n    //     return;\n    //   }\n    // }\n\n    if (!mapObj[nextPossibleCell]) {\n      return nextPossibleMoves[nextPossibleCell] = \"empty\";\n    } else if (mapObj[nextPossibleCell].player !== player) {\n      return nextPossibleMoves[nextPossibleCell] = \"eat\";\n    } else return {};\n  };\n\n  const findPath = fromSquare => {\n    let nextPossibleMoves = {};\n\n    if (!fromSquare) {\n      return {};\n    } else if (!mapObj[fromSquare]) {\n      return {};\n    }\n\n    const [moveFromRow, moveFromCol] = parseToNumber(fromSquare);\n\n    const bishopFunctionInfo = i => {\n      addPossibleCellToPath(fromSquare, moveFromRow + i, moveFromCol + i, nextPossibleMoves);\n      addPossibleCellToPath(fromSquare, moveFromRow - i, moveFromCol - i, nextPossibleMoves);\n      addPossibleCellToPath(fromSquare, moveFromRow + i, moveFromCol - i, nextPossibleMoves);\n      addPossibleCellToPath(fromSquare, moveFromRow - i, moveFromCol + i, nextPossibleMoves);\n    };\n\n    const pawnFunctionInfo = () => {\n      addPossibleCellToPath(fromSquare, moveFromRow - 1, moveFromCol, nextPossibleMoves);\n      addPossibleCellToPath(fromSquare, moveFromRow + 1, moveFromCol, nextPossibleMoves);\n    };\n\n    if (mapObj[fromSquare].type === \"pawn\") {\n      const fromSquareToNum = Number(fromSquare);\n\n      const getNextPawnMove = () => {\n        if (mapObj[fromSquare].player === false) {\n          if (fromSquare[0] === \"1\") {\n            //if its first move, pawn can move 2 squares\n            addPossibleCellToPath(fromSquare, moveFromRow + 2, moveFromCol, nextPossibleMoves);\n            addPossibleCellToPath(fromSquare, moveFromRow + 1, moveFromCol, nextPossibleMoves);\n            return nextPossibleMoves;\n          }\n\n          if (mapObj[(fromSquareToNum + 11).toString()]) {\n            //check if the pawn my eat\n            if (mapObj[(fromSquareToNum + 11).toString()].player !== mapObj[fromSquare].player) {\n              addPossibleCellToPath(fromSquare, moveFromRow + 1, moveFromCol + 1, nextPossibleMoves);\n            }\n          }\n        }\n\n        addPossibleCellToPath(fromSquare, moveFromRow + 1, moveFromCol, nextPossibleMoves);\n        console.log(nextPossibleMoves);\n\n        if (mapObj[fromSquare].player === true) {\n          if (fromSquare[0] === \"6\") {\n            //if its first move, pawn can move 2 squares\n            addPossibleCellToPath(fromSquare, moveFromRow - 2, moveFromCol, nextPossibleMoves);\n            addPossibleCellToPath(fromSquare, moveFromRow - 1, moveFromCol, nextPossibleMoves);\n            return nextPossibleMoves;\n          }\n\n          addPossibleCellToPath(fromSquare, moveFromRow - 1, moveFromCol, nextPossibleMoves);\n\n          if (mapObj[(fromSquareToNum - 11).toString()]) {\n            //check if the pawn may eat\n            if (mapObj[(fromSquareToNum - 11).toString()].player !== mapObj[fromSquare].player) {\n              addPossibleCellToPath(fromSquare, moveFromRow - 1, moveFromCol - 1, nextPossibleMoves);\n            }\n          }\n        }\n\n        pawnFunctionInfo();\n        return nextPossibleMoves;\n      };\n\n      const result = getNextPawnMove(fromSquare);\n      console.log(\"kkk\", result);\n      return result;\n    } // console.log(fromSquare, mapObj);\n\n\n    if (mapObj[fromSquare].type === \"knight\") {\n      const getNextKnightMove = () => {\n        addPossibleCellToPath(fromSquare, moveFromRow - 2, moveFromCol + 1, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow - 2, moveFromCol - 1, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow + 2, moveFromCol + 1, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow + 2, moveFromCol - 1, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow - 1, moveFromCol + 2, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow - 1, moveFromCol - 2, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow + 1, moveFromCol + 2, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow + 1, moveFromCol - 2, nextPossibleMoves);\n        return nextPossibleMoves;\n      };\n\n      const result = getNextKnightMove(fromSquare);\n      console.log(\"kkk\", result);\n      return result;\n    }\n\n    if (mapObj[fromSquare].type === \"bishop\") {\n      const getNextBishopMove = () => {\n        for (let i = fromSquare[0]; i <= 7; i++) {\n          bishopFunctionInfo(i);\n        }\n\n        for (let i = fromSquare[0]; i >= 0; i--) {\n          bishopFunctionInfo(i);\n        }\n\n        return nextPossibleMoves;\n      };\n\n      const result = getNextBishopMove(fromSquare);\n      console.log(\"kkk\", result);\n      return result;\n    }\n\n    if (mapObj[fromSquare].type === \"queen\") {\n      const getNextQueenMove = () => {\n        for (let i = 1; i <= 7; i++) {\n          bishopFunctionInfo(i);\n        }\n\n        return nextPossibleMoves;\n      };\n\n      const result = getNextQueenMove(fromSquare);\n      console.log(\"kkk\", result);\n      return result;\n    }\n\n    if (mapObj[fromSquare].type === \"king\") {\n      const getNextKingMove = () => {\n        pawnFunctionInfo();\n        addPossibleCellToPath(fromSquare, moveFromRow + 1, moveFromCol - 1, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow + 1, moveFromCol + 1, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow, moveFromCol - 1, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow, moveFromCol + 1, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow - 1, moveFromCol - 1, nextPossibleMoves);\n        addPossibleCellToPath(fromSquare, moveFromRow - 1, moveFromCol + 1, nextPossibleMoves);\n        return nextPossibleMoves;\n      };\n\n      const result = getNextKingMove(fromSquare);\n      console.log(\"kkk\", result);\n      return result;\n    }\n\n    if (mapObj[fromSquare].type === \"rook\") {\n      console.log(\"rooked\"); // get's the square (index) of the square above the given  index\n\n      const getSquareAbove = square => {\n        //getting the string square and return the next square going up as a number\n        const squareNum = Number(square);\n        return squareNum - 10;\n      };\n\n      const getSquareDown = square => {\n        //getting the string square and return the next square going down as a number\n        const squareNum = Number(square);\n        return squareNum + 10;\n      };\n\n      const getSquareLeft = square => {\n        //getting the string square and return the next square going left as a number\n        const squareNum = Number(square);\n        return squareNum - 1;\n      }; // const getSquareRight = (square) => {\n      //   //getting the string square and return the next square going right as a number\n      //   const squareNum = Number(square);\n      //   return squareNum + 1;\n      // };\n\n\n      const movableSquaresAbove = findMovableSquaresInDirection({\n        startingSquare: fromSquare,\n        getNextSquareFn: getSquareAbove,\n        mapObj\n      });\n      const movableSquaresDown = findMovableSquaresInDirection({\n        startingSquare: fromSquare,\n        getNextSquareFn: getSquareDown,\n        mapObj\n      });\n      const movableSquaresLeft = findMovableSquaresInDirection({\n        startingSquare: fromSquare,\n        getNextSquareFn: getSquareLeft,\n        mapObj\n      });\n      console.log(\"kkk\", movableSquaresAbove);\n      console.log(\"kkk\", movableSquaresDown);\n      return { ...movableSquaresAbove,\n        ...movableSquaresDown,\n        ...movableSquaresLeft\n      };\n    }\n  };\n\n  const handleClick = con => {\n    if (count === 0) {\n      if (!mapObj[con]) {\n        //first spuare to click cant be empty\n        return;\n      }\n    }\n\n    if (count === 0) {\n      setFromSquare(con);\n      setCount(count + 1);\n      console.log(\"this con mada\", con);\n      setChosen(con);\n      console.log(\"chosen:\", chosen);\n      return;\n    } //second click\n    // fromSquare -> toSqaure\n\n\n    if (!mapObj[con] || mapObj[fromSquare].player !== mapObj[con].player) {\n      // check if the square we move to is empty or filled with the other player\n      const moveFigureFromSquareToSquare = (fromSquare, con) => {\n        // console.log(\"out here checkin\", fromSquare, con);\n        if (findPath(fromSquare)[con]) {\n          //check if the second click is in path => can move\n          const returnPathArr = Object.values(findPath(fromSquare));\n\n          for (let i = 0; i <= returnPathArr.length; i++) {\n            // console.log(\"im fromsquare:\", fromSquare);\n            // console.log(\"im the fucking return array:\", returnPathArr);\n            //scan through path and not let passing through NON-EMPTY\n            if (returnPathArr[i] === \"empty\" || returnPathArr[i] === \"eat\") {\n              // if the square is empty or eatable you may move\n              // console.log(\"i survived\");\n              moveInvoke(fromSquare, con);\n              setCount(0);\n              return;\n            }\n\n            return;\n          }\n        }\n      };\n\n      moveFigureFromSquareToSquare(fromSquare, con);\n    }\n\n    setCount(0);\n  };\n\n  console.log(chosen);\n  const path = findPath(chosen);\n  console.log(path);\n  return (\n    /*#__PURE__*/\n    // we will map 8 * 8 of arrays to build our board.\n    React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 514,\n        columnNumber: 5\n      }\n    }, Array(8).fill(0).map((e, rowIndex) => {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        style: {\n          display: \"flex\",\n          flexDirection: \"row\"\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 519,\n          columnNumber: 13\n        }\n      }, Array(8).fill(0).map((e, squareIndex) => {\n        const colorPic = (squareIndex + rowIndex) % 2 === 0 ? true : false; // we will caculate the spread of black & white color on the board and identify each square\n\n        const numRow = rowIndex.toString();\n        const numSquare = squareIndex.toString();\n        const con = numRow.concat(numSquare);\n        const piece = mapObj[con];\n        const isHighlighted = path[con] ? true : false;\n        console.log(isHighlighted);\n        return (\n          /*#__PURE__*/\n          //props\n          React.createElement(Square, {\n            isHighlighted: isHighlighted,\n            color: colorPic,\n            piece: piece,\n            onClick: () => handleClick(con) // onMouseOver={() => handleMouseOver(colorPic)}\n            ,\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 539,\n              columnNumber: 21\n            }\n          })\n        );\n      }));\n    }), /*#__PURE__*/React.createElement(\"h1\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 552,\n        columnNumber: 7\n      }\n    }, printCheckOutside), /*#__PURE__*/React.createElement(\"h1\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 553,\n        columnNumber: 7\n      }\n    }, printPlayerOutside))\n  );\n};\n\nfunction App() {\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 560,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(Board, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 561,\n      columnNumber: 7\n    }\n  }));\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/mac/Chess/src/App.js"],"names":["React","useState","useEffect","Square","findMovableSquaresInDirection","mapObj","type","player","Board","count","setCount","fromSquare","setFromSquare","setPlayer","check","setCheck","chosen","setChosen","printCheckOutside","printPlayerOutside","printCheck","printPlayer","moveInvoke","moveFrom","moveTo","movePiece","findKing","startingSquare","entries","Object","i","length","kingIndex","console","log","toSquare","movingContent","parseToNumber","square","row","col","split","parseInt","addPossibleCellToPath","nextPossibleRow","nextPossibleCol","nextPossibleMoves","typeOfSquare","nextPossibleCell","toString","findPath","moveFromRow","moveFromCol","bishopFunctionInfo","pawnFunctionInfo","fromSquareToNum","Number","getNextPawnMove","result","getNextKnightMove","getNextBishopMove","getNextQueenMove","getNextKingMove","getSquareAbove","squareNum","getSquareDown","getSquareLeft","movableSquaresAbove","getNextSquareFn","movableSquaresDown","movableSquaresLeft","handleClick","con","moveFigureFromSquareToSquare","returnPathArr","values","path","Array","fill","map","e","rowIndex","display","flexDirection","squareIndex","colorPic","numRow","numSquare","concat","piece","isHighlighted","App"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,QAA2C,OAA3C,C,CACA;;AACA,OAAO,WAAP;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,SAASC,6BAAT,QAA8C,sBAA9C;AAEA,MAAMC,MAAM,GAAG;AACb;AACA,QAAM;AAAEC,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAFO;AAGb,QAAM;AAAED,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,MAAM,EAAE;AAA1B,GAHO;AAIb,QAAM;AAAED,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,MAAM,EAAE;AAA1B,GAJO;AAKb,QAAM;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GALO;AAMb,QAAM;AAAED,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,MAAM,EAAE;AAAzB,GANO;AAOb,QAAM;AAAED,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,MAAM,EAAE;AAA1B,GAPO;AAQb,QAAM;AAAED,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,MAAM,EAAE;AAA1B,GARO;AASb,QAAM;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GATO;AAUb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAVS;AAWb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAXS;AAYb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAZS;AAab,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAbS;AAcb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAdS;AAeb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAfS;AAgBb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAhBS;AAiBb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAjBS;AAkBb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAlBS;AAmBb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAnBS;AAoBb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GApBS;AAqBb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GArBS;AAsBb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAtBS;AAuBb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAvBS;AAwBb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAxBS;AAyBb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAzBS;AA0Bb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GA1BS;AA2Bb,MAAI;AAAED,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,MAAM,EAAE;AAA1B,GA3BS;AA4Bb,MAAI;AAAED,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,MAAM,EAAE;AAA1B,GA5BS;AA6Bb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GA7BS;AA8Bb,MAAI;AAAED,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,MAAM,EAAE;AAAzB,GA9BS;AA+Bb,MAAI;AAAED,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,MAAM,EAAE;AAA1B,GA/BS;AAgCb,MAAI;AAAED,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,MAAM,EAAE;AAA1B,GAhCS;AAiCb,MAAI;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,MAAM,EAAE;AAAxB;AAjCS,CAAf;;AAoCA,MAAMC,KAAK,GAAG,MAAM;AAClB,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBT,QAAQ,CAAC,CAAD,CAAlC;AACA,QAAM,CAACU,UAAD,EAAaC,aAAb,IAA8BX,QAAQ,EAA5C;AACA,QAAM,CAACM,MAAD,EAASM,SAAT,IAAsBZ,QAAQ,CAAC,IAAD,CAApC;AACA,QAAM,CAACa,KAAD,EAAQC,QAAR,IAAoBd,QAAQ,CAAC,KAAD,CAAlC;AACA,QAAM,CAACe,MAAD,EAASC,SAAT,IAAsBhB,QAAQ,EAApC;AAEA,MAAIiB,iBAAJ;AACA,MAAIC,kBAAJ;;AACA,QAAMC,UAAU,GAAIN,KAAD,IAAW;AAC5BA,IAAAA,KAAK,KAAK,KAAV,GACKI,iBAAiB,GAAG,wBADzB,GAEKA,iBAAiB,GAAG,iCAFzB;AAGD,GAJD;;AAKA,QAAMG,WAAW,GAAId,MAAD,IAAY;AAC9BA,IAAAA,MAAM,KAAK,IAAX,GACKY,kBAAkB,GAAG,qBAD1B,GAEKA,kBAAkB,GAAG,oBAF1B;AAGD,GAJD;;AAKAC,EAAAA,UAAU,CAACN,KAAD,CAAV;AACAO,EAAAA,WAAW,CAACd,MAAD,CAAX;;AACA,QAAMe,UAAU,GAAG,CAACC,QAAD,EAAWC,MAAX,KAAsB;AACvC;AACAC,IAAAA,SAAS,CAACF,QAAD,EAAWC,MAAX,CAAT;AACD,GAHD,CArBkB,CA0BlB;;;AACA,QAAME,QAAQ,GAAIC,cAAD,IAAoB;AACnC;AACA,UAAMC,OAAO,GAAGC,MAAM,CAACD,OAAP,CAAevB,MAAf,CAAhB;;AACA,SAAK,IAAIyB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIF,OAAO,CAACG,MAAR,GAAiB,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,UAAIE,SAAJ;;AACA,UAAIJ,OAAO,CAACE,CAAD,CAAP,CAAW,CAAX,EAAcxB,IAAd,KAAuB,MAA3B,EAAmC;AACjC,YAAIsB,OAAO,CAACE,CAAD,CAAP,CAAW,CAAX,EAAcvB,MAAd,KAAyBF,MAAM,CAACsB,cAAD,CAAN,CAAuBpB,MAApD,EAA4D;AAC1DyB,UAAAA,SAAS,GAAGJ,OAAO,CAACE,CAAD,CAAP,CAAW,CAAX,CAAZ;AACAG,UAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ,EAA+BF,SAA/B;AACA,iBAAOA,SAAP;AACD;AACF;AACF;AACF,GAbD;;AAeA,QAAMP,SAAS,GAAG,CAACd,UAAD,EAAawB,QAAb,KAA0B;AAC1C,UAAMC,aAAa,GAAG,MAAM;AAC1B;AAEA;AACA;AACA;AACA,UAAItB,KAAK,KAAK,IAAd,EAAoB;AAClB;AACD,OARyB,CAS1B;;;AACAT,MAAAA,MAAM,CAAC8B,QAAD,CAAN,GAAmB9B,MAAM,CAACM,UAAD,CAAzB;AACA,aAAON,MAAM,CAACM,UAAD,CAAb;AACAE,MAAAA,SAAS,CAAC,CAACN,MAAF,CAAT;AACD,KAbD;;AAcA,QAAIA,MAAM,KAAK,IAAf,EAAqB;AACnB,UAAIF,MAAM,CAACM,UAAD,CAAN,CAAmBJ,MAAnB,KAA8B,IAAlC,EAAwC;AACtC6B,QAAAA,aAAa;AACd;AACF,KAJD,MAIO,IAAI7B,MAAM,KAAK,KAAf,EAAsB;AAC3B,UAAIF,MAAM,CAACM,UAAD,CAAN,CAAmBJ,MAAnB,KAA8B,KAAlC,EAAyC;AACvC6B,QAAAA,aAAa;AACd;AACF;AACF,GAxBD,CA1CkB,CAmElB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,QAAMC,aAAa,GAAIC,MAAD,IAAY;AAChC,UAAM,CAACC,GAAD,EAAMC,GAAN,IAAaF,MAAM,CAACG,KAAP,CAAa,EAAb,CAAnB;AACA,WAAO,CAACC,QAAQ,CAACH,GAAD,CAAT,EAAgBG,QAAQ,CAACF,GAAD,CAAxB,CAAP;AACD,GAHD;;AAKA,QAAMG,qBAAqB,GAAG,CAC5BhC,UAD4B,EAE5BiC,eAF4B,EAG5BC,eAH4B,EAI5BC,iBAJ4B,KAKzB;AACH,UAAMvC,MAAM,GAAGF,MAAM,CAACM,UAAD,CAAN,CAAmBJ,MAAlC;AACA,UAAMwC,YAAY,GAAG1C,MAAM,CAACM,UAAD,CAAN,CAAmBL,IAAxC;AACA,UAAM0C,gBAAgB,GACpBJ,eAAe,CAACK,QAAhB,KAA6BJ,eAAe,CAACI,QAAhB,EAD/B,CAHG,CAKH;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAI,CAAC5C,MAAM,CAAC2C,gBAAD,CAAX,EAA+B;AAC7B,aAAQF,iBAAiB,CAACE,gBAAD,CAAjB,GAAsC,OAA9C;AACD,KAFD,MAEO,IAAI3C,MAAM,CAAC2C,gBAAD,CAAN,CAAyBzC,MAAzB,KAAoCA,MAAxC,EAAgD;AACrD,aAAQuC,iBAAiB,CAACE,gBAAD,CAAjB,GAAsC,KAA9C;AACD,KAFM,MAEA,OAAO,EAAP;AACR,GAtBD;;AAwBA,QAAME,QAAQ,GAAIvC,UAAD,IAAgB;AAC/B,QAAImC,iBAAiB,GAAG,EAAxB;;AACA,QAAI,CAACnC,UAAL,EAAiB;AACf,aAAO,EAAP;AACD,KAFD,MAEO,IAAI,CAACN,MAAM,CAACM,UAAD,CAAX,EAAyB;AAC9B,aAAO,EAAP;AACD;;AACD,UAAM,CAACwC,WAAD,EAAcC,WAAd,IAA6Bf,aAAa,CAAC1B,UAAD,CAAhD;;AACA,UAAM0C,kBAAkB,GAAIvB,CAAD,IAAO;AAChCa,MAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAGrB,CAFK,EAGnBsB,WAAW,GAAGtB,CAHK,EAInBgB,iBAJmB,CAArB;AAMAH,MAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAGrB,CAFK,EAGnBsB,WAAW,GAAGtB,CAHK,EAInBgB,iBAJmB,CAArB;AAMAH,MAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAGrB,CAFK,EAGnBsB,WAAW,GAAGtB,CAHK,EAInBgB,iBAJmB,CAArB;AAMAH,MAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAGrB,CAFK,EAGnBsB,WAAW,GAAGtB,CAHK,EAInBgB,iBAJmB,CAArB;AAMD,KAzBD;;AA0BA,UAAMQ,gBAAgB,GAAG,MAAM;AAC7BX,MAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAHmB,EAInBN,iBAJmB,CAArB;AAMAH,MAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAHmB,EAInBN,iBAJmB,CAArB;AAMD,KAbD;;AAcA,QAAIzC,MAAM,CAACM,UAAD,CAAN,CAAmBL,IAAnB,KAA4B,MAAhC,EAAwC;AACtC,YAAMiD,eAAe,GAAGC,MAAM,CAAC7C,UAAD,CAA9B;;AACA,YAAM8C,eAAe,GAAG,MAAM;AAC5B,YAAIpD,MAAM,CAACM,UAAD,CAAN,CAAmBJ,MAAnB,KAA8B,KAAlC,EAAyC;AACvC,cAAII,UAAU,CAAC,CAAD,CAAV,KAAkB,GAAtB,EAA2B;AACzB;AACAgC,YAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAHmB,EAInBN,iBAJmB,CAArB;AAMAH,YAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAHmB,EAInBN,iBAJmB,CAArB;AAMA,mBAAOA,iBAAP;AACD;;AACD,cAAIzC,MAAM,CAAC,CAACkD,eAAe,GAAG,EAAnB,EAAuBN,QAAvB,EAAD,CAAV,EAA+C;AAC7C;AACA,gBACE5C,MAAM,CAAC,CAACkD,eAAe,GAAG,EAAnB,EAAuBN,QAAvB,EAAD,CAAN,CAA0C1C,MAA1C,KACAF,MAAM,CAACM,UAAD,CAAN,CAAmBJ,MAFrB,EAGE;AACAoC,cAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMD;AACF;AACF;;AACDH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAHmB,EAInBN,iBAJmB,CAArB;AAMAb,QAAAA,OAAO,CAACC,GAAR,CAAYY,iBAAZ;;AACA,YAAIzC,MAAM,CAACM,UAAD,CAAN,CAAmBJ,MAAnB,KAA8B,IAAlC,EAAwC;AACtC,cAAII,UAAU,CAAC,CAAD,CAAV,KAAkB,GAAtB,EAA2B;AACzB;AACAgC,YAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAHmB,EAInBN,iBAJmB,CAArB;AAMAH,YAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAHmB,EAInBN,iBAJmB,CAArB;AAMA,mBAAOA,iBAAP;AACD;;AACDH,UAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAHmB,EAInBN,iBAJmB,CAArB;;AAMA,cAAIzC,MAAM,CAAC,CAACkD,eAAe,GAAG,EAAnB,EAAuBN,QAAvB,EAAD,CAAV,EAA+C;AAC7C;AACA,gBACE5C,MAAM,CAAC,CAACkD,eAAe,GAAG,EAAnB,EAAuBN,QAAvB,EAAD,CAAN,CAA0C1C,MAA1C,KACAF,MAAM,CAACM,UAAD,CAAN,CAAmBJ,MAFrB,EAGE;AACAoC,cAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMD;AACF;AACF;;AACDQ,QAAAA,gBAAgB;AAChB,eAAOR,iBAAP;AACD,OAhFD;;AAiFA,YAAMY,MAAM,GAAGD,eAAe,CAAC9C,UAAD,CAA9B;AAEAsB,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmBwB,MAAnB;AACA,aAAOA,MAAP;AACD,KAvI8B,CAwI/B;;;AACA,QAAIrD,MAAM,CAACM,UAAD,CAAN,CAAmBL,IAAnB,KAA4B,QAAhC,EAA0C;AACxC,YAAMqD,iBAAiB,GAAG,MAAM;AAC9BhB,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAOAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMA,eAAOA,iBAAP;AACD,OAnDD;;AAoDA,YAAMY,MAAM,GAAGC,iBAAiB,CAAChD,UAAD,CAAhC;AAEAsB,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmBwB,MAAnB;AACA,aAAOA,MAAP;AACD;;AACD,QAAIrD,MAAM,CAACM,UAAD,CAAN,CAAmBL,IAAnB,KAA4B,QAAhC,EAA0C;AACxC,YAAMsD,iBAAiB,GAAG,MAAM;AAC9B,aAAK,IAAI9B,CAAC,GAAGnB,UAAU,CAAC,CAAD,CAAvB,EAA4BmB,CAAC,IAAI,CAAjC,EAAoCA,CAAC,EAArC,EAAyC;AACvCuB,UAAAA,kBAAkB,CAACvB,CAAD,CAAlB;AACD;;AACD,aAAK,IAAIA,CAAC,GAAGnB,UAAU,CAAC,CAAD,CAAvB,EAA4BmB,CAAC,IAAI,CAAjC,EAAoCA,CAAC,EAArC,EAAyC;AACvCuB,UAAAA,kBAAkB,CAACvB,CAAD,CAAlB;AACD;;AACD,eAAOgB,iBAAP;AACD,OARD;;AASA,YAAMY,MAAM,GAAGE,iBAAiB,CAACjD,UAAD,CAAhC;AAEAsB,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmBwB,MAAnB;AACA,aAAOA,MAAP;AACD;;AACD,QAAIrD,MAAM,CAACM,UAAD,CAAN,CAAmBL,IAAnB,KAA4B,OAAhC,EAAyC;AACvC,YAAMuD,gBAAgB,GAAG,MAAM;AAC7B,aAAK,IAAI/B,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3BuB,UAAAA,kBAAkB,CAACvB,CAAD,CAAlB;AACD;;AACD,eAAOgB,iBAAP;AACD,OALD;;AAMA,YAAMY,MAAM,GAAGG,gBAAgB,CAAClD,UAAD,CAA/B;AAEAsB,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmBwB,MAAnB;AACA,aAAOA,MAAP;AACD;;AACD,QAAIrD,MAAM,CAACM,UAAD,CAAN,CAAmBL,IAAnB,KAA4B,MAAhC,EAAwC;AACtC,YAAMwD,eAAe,GAAG,MAAM;AAC5BR,QAAAA,gBAAgB;AAChBX,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAFmB,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAFmB,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMAH,QAAAA,qBAAqB,CACnBhC,UADmB,EAEnBwC,WAAW,GAAG,CAFK,EAGnBC,WAAW,GAAG,CAHK,EAInBN,iBAJmB,CAArB;AAMA,eAAOA,iBAAP;AACD,OAvCD;;AAwCA,YAAMY,MAAM,GAAGI,eAAe,CAACnD,UAAD,CAA9B;AAEAsB,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmBwB,MAAnB;AACA,aAAOA,MAAP;AACD;;AACD,QAAIrD,MAAM,CAACM,UAAD,CAAN,CAAmBL,IAAnB,KAA4B,MAAhC,EAAwC;AACtC2B,MAAAA,OAAO,CAACC,GAAR,CAAY,QAAZ,EADsC,CAGtC;;AACA,YAAM6B,cAAc,GAAIzB,MAAD,IAAY;AACjC;AACA,cAAM0B,SAAS,GAAGR,MAAM,CAAClB,MAAD,CAAxB;AACA,eAAO0B,SAAS,GAAG,EAAnB;AACD,OAJD;;AAKA,YAAMC,aAAa,GAAI3B,MAAD,IAAY;AAChC;AACA,cAAM0B,SAAS,GAAGR,MAAM,CAAClB,MAAD,CAAxB;AACA,eAAO0B,SAAS,GAAG,EAAnB;AACD,OAJD;;AAKA,YAAME,aAAa,GAAI5B,MAAD,IAAY;AAChC;AACA,cAAM0B,SAAS,GAAGR,MAAM,CAAClB,MAAD,CAAxB;AACA,eAAO0B,SAAS,GAAG,CAAnB;AACD,OAJD,CAdsC,CAmBtC;AACA;AACA;AACA;AACA;;;AACA,YAAMG,mBAAmB,GAAG/D,6BAA6B,CAAC;AACxDuB,QAAAA,cAAc,EAAEhB,UADwC;AAExDyD,QAAAA,eAAe,EAAEL,cAFuC;AAGxD1D,QAAAA;AAHwD,OAAD,CAAzD;AAKA,YAAMgE,kBAAkB,GAAGjE,6BAA6B,CAAC;AACvDuB,QAAAA,cAAc,EAAEhB,UADuC;AAEvDyD,QAAAA,eAAe,EAAEH,aAFsC;AAGvD5D,QAAAA;AAHuD,OAAD,CAAxD;AAKA,YAAMiE,kBAAkB,GAAGlE,6BAA6B,CAAC;AACvDuB,QAAAA,cAAc,EAAEhB,UADuC;AAEvDyD,QAAAA,eAAe,EAAEF,aAFsC;AAGvD7D,QAAAA;AAHuD,OAAD,CAAxD;AAMA4B,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmBiC,mBAAnB;AACAlC,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmBmC,kBAAnB;AACA,aAAO,EACL,GAAGF,mBADE;AAEL,WAAGE,kBAFE;AAGL,WAAGC;AAHE,OAAP;AAKD;AACF,GA5TD;;AA6TA,QAAMC,WAAW,GAAIC,GAAD,IAAS;AAC3B,QAAI/D,KAAK,KAAK,CAAd,EAAiB;AACf,UAAI,CAACJ,MAAM,CAACmE,GAAD,CAAX,EAAkB;AAChB;AACA;AACD;AACF;;AACD,QAAI/D,KAAK,KAAK,CAAd,EAAiB;AACfG,MAAAA,aAAa,CAAC4D,GAAD,CAAb;AACA9D,MAAAA,QAAQ,CAACD,KAAK,GAAG,CAAT,CAAR;AACAwB,MAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6BsC,GAA7B;AACAvD,MAAAA,SAAS,CAACuD,GAAD,CAAT;AACAvC,MAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBlB,MAAvB;AACA;AACD,KAd0B,CAe3B;AACA;;;AACA,QAAI,CAACX,MAAM,CAACmE,GAAD,CAAP,IAAgBnE,MAAM,CAACM,UAAD,CAAN,CAAmBJ,MAAnB,KAA8BF,MAAM,CAACmE,GAAD,CAAN,CAAYjE,MAA9D,EAAsE;AACpE;AACA,YAAMkE,4BAA4B,GAAG,CAAC9D,UAAD,EAAa6D,GAAb,KAAqB;AACxD;AACA,YAAItB,QAAQ,CAACvC,UAAD,CAAR,CAAqB6D,GAArB,CAAJ,EAA+B;AAC7B;AACA,gBAAME,aAAa,GAAG7C,MAAM,CAAC8C,MAAP,CAAczB,QAAQ,CAACvC,UAAD,CAAtB,CAAtB;;AACA,eAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI4C,aAAa,CAAC3C,MAAnC,EAA2CD,CAAC,EAA5C,EAAgD;AAC9C;AACA;AACA;AACA,gBAAI4C,aAAa,CAAC5C,CAAD,CAAb,KAAqB,OAArB,IAAgC4C,aAAa,CAAC5C,CAAD,CAAb,KAAqB,KAAzD,EAAgE;AAC9D;AACA;AACAR,cAAAA,UAAU,CAACX,UAAD,EAAa6D,GAAb,CAAV;AACA9D,cAAAA,QAAQ,CAAC,CAAD,CAAR;AACA;AACD;;AACD;AACD;AACF;AACF,OAnBD;;AAoBA+D,MAAAA,4BAA4B,CAAC9D,UAAD,EAAa6D,GAAb,CAA5B;AACD;;AACD9D,IAAAA,QAAQ,CAAC,CAAD,CAAR;AACD,GA1CD;;AA4CAuB,EAAAA,OAAO,CAACC,GAAR,CAAYlB,MAAZ;AACA,QAAM4D,IAAI,GAAG1B,QAAQ,CAAClC,MAAD,CAArB;AACAiB,EAAAA,OAAO,CAACC,GAAR,CAAY0C,IAAZ;AAEA;AAAA;AACE;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACGC,KAAK,CAAC,CAAD,CAAL,CACEC,IADF,CACO,CADP,EAEEC,GAFF,CAEM,CAACC,CAAD,EAAIC,QAAJ,KAAiB;AACpB,0BACE;AACE,QAAA,KAAK,EAAE;AACLC,UAAAA,OAAO,EAAE,MADJ;AAELC,UAAAA,aAAa,EAAE;AAFV,SADT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAMGN,KAAK,CAAC,CAAD,CAAL,CACEC,IADF,CACO,CADP,EAEEC,GAFF,CAEM,CAACC,CAAD,EAAII,WAAJ,KAAoB;AACvB,cAAMC,QAAQ,GACZ,CAACD,WAAW,GAAGH,QAAf,IAA2B,CAA3B,KAAiC,CAAjC,GAAqC,IAArC,GAA4C,KAD9C,CADuB,CAGvB;;AACA,cAAMK,MAAM,GAAGL,QAAQ,CAAChC,QAAT,EAAf;AACA,cAAMsC,SAAS,GAAGH,WAAW,CAACnC,QAAZ,EAAlB;AACA,cAAMuB,GAAG,GAAGc,MAAM,CAACE,MAAP,CAAcD,SAAd,CAAZ;AACA,cAAME,KAAK,GAAGpF,MAAM,CAACmE,GAAD,CAApB;AACA,cAAMkB,aAAa,GAAGd,IAAI,CAACJ,GAAD,CAAJ,GAAY,IAAZ,GAAmB,KAAzC;AACAvC,QAAAA,OAAO,CAACC,GAAR,CAAYwD,aAAZ;AACA;AAAA;AACE;AACA,8BAAC,MAAD;AACE,YAAA,aAAa,EAAEA,aADjB;AAEE,YAAA,KAAK,EAAEL,QAFT;AAGE,YAAA,KAAK,EAAEI,KAHT;AAIE,YAAA,OAAO,EAAE,MAAMlB,WAAW,CAACC,GAAD,CAJ5B,CAME;AANF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFF;AAWD,OAvBF,CANH,CADF;AAiCD,KApCF,CADH,eAsCE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAKtD,iBAAL,CAtCF,eAuCE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAKC,kBAAL,CAvCF;AAFF;AA4CD,CAjgBD;;AAmgBA,SAASwE,GAAT,GAAe;AACb,sBACE;AAAK,IAAA,SAAS,EAAC,KAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE,oBAAC,KAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADF,CADF;AAKD;;AAED,eAAeA,GAAf","sourcesContent":["import React, { useState, useEffect } from \"react\";\n// import logo from \"./logo.svg\";\nimport \"./App.css\";\nimport Square from \"./Square\";\nimport { findMovableSquaresInDirection } from \"./findMovableSquares\";\n\nconst mapObj = {\n  //database of the board\n  \"00\": { type: \"rook\", player: false },\n  \"01\": { type: \"knight\", player: false },\n  \"02\": { type: \"bishop\", player: false },\n  \"03\": { type: \"king\", player: false },\n  \"04\": { type: \"queen\", player: false },\n  \"05\": { type: \"bishop\", player: false },\n  \"06\": { type: \"knight\", player: false },\n  \"07\": { type: \"rook\", player: false },\n  10: { type: \"pawn\", player: false },\n  11: { type: \"pawn\", player: false },\n  12: { type: \"pawn\", player: false },\n  13: { type: \"pawn\", player: false },\n  14: { type: \"pawn\", player: false },\n  15: { type: \"pawn\", player: false },\n  16: { type: \"pawn\", player: false },\n  17: { type: \"pawn\", player: false },\n  60: { type: \"pawn\", player: true },\n  61: { type: \"pawn\", player: true },\n  62: { type: \"pawn\", player: true },\n  63: { type: \"pawn\", player: true },\n  64: { type: \"pawn\", player: true },\n  65: { type: \"pawn\", player: true },\n  66: { type: \"pawn\", player: true },\n  67: { type: \"pawn\", player: true },\n  70: { type: \"rook\", player: true },\n  71: { type: \"knight\", player: true },\n  72: { type: \"bishop\", player: true },\n  73: { type: \"king\", player: true },\n  74: { type: \"queen\", player: true },\n  75: { type: \"bishop\", player: true },\n  76: { type: \"knight\", player: true },\n  77: { type: \"rook\", player: true },\n};\n\nconst Board = () => {\n  const [count, setCount] = useState(0);\n  const [fromSquare, setFromSquare] = useState();\n  const [player, setPlayer] = useState(true);\n  const [check, setCheck] = useState(false);\n  const [chosen, setChosen] = useState();\n\n  let printCheckOutside;\n  let printPlayerOutside;\n  const printCheck = (check) => {\n    check === false\n      ? (printCheckOutside = \"no check at this point\")\n      : (printCheckOutside = \"check, please protect your King\");\n  };\n  const printPlayer = (player) => {\n    player === true\n      ? (printPlayerOutside = \"white player's turn\")\n      : (printPlayerOutside = \"blue player's turn\");\n  };\n  printCheck(check);\n  printPlayer(player);\n  const moveInvoke = (moveFrom, moveTo) => {\n    // the actual movePiece\n    movePiece(moveFrom, moveTo);\n  };\n\n  // checking if theres a check in play\n  const findKing = (startingSquare) => {\n    // here we find the king's key (location)\n    const entries = Object.entries(mapObj);\n    for (let i = 0; i <= entries.length - 1; i++) {\n      let kingIndex;\n      if (entries[i][1].type === \"king\") {\n        if (entries[i][1].player !== mapObj[startingSquare].player) {\n          kingIndex = entries[i][0];\n          console.log(\"insideFindKing:\", kingIndex);\n          return kingIndex;\n        }\n      }\n    }\n  };\n\n  const movePiece = (fromSquare, toSquare) => {\n    const movingContent = () => {\n      // here we will move the actual piece from one sqaure to another.\n\n      // 1. mapObj[toSquare] = mapObj[fromSquare] to the obj\n      // 2. delete the property whose key is \"fromSquare\" from mapObj\n      // const path = getTheFigurePath(fromSquare, toSquare);\n      if (check === true) {\n        return;\n      }\n      // if (!checkPath(path)) return;\n      mapObj[toSquare] = mapObj[fromSquare];\n      delete mapObj[fromSquare];\n      setPlayer(!player);\n    };\n    if (player === true) {\n      if (mapObj[fromSquare].player === true) {\n        movingContent();\n      }\n    } else if (player === false) {\n      if (mapObj[fromSquare].player === false) {\n        movingContent();\n      }\n    }\n  };\n  // useEffect(() => {\n  //   console.log(\"inEffect\", fromSquare, toSquare);\n  //   if (fromSquare && toSquare) {\n  //     movePiece(fromSquare, toSquare);\n  //     // setToSquare();\n  //   }\n  // }, [fromSquare, toSquare]);\n\n  const parseToNumber = (square) => {\n    const [row, col] = square.split(\"\");\n    return [parseInt(row), parseInt(col)];\n  };\n\n  const addPossibleCellToPath = (\n    fromSquare,\n    nextPossibleRow,\n    nextPossibleCol,\n    nextPossibleMoves\n  ) => {\n    const player = mapObj[fromSquare].player;\n    const typeOfSquare = mapObj[fromSquare].type;\n    const nextPossibleCell =\n      nextPossibleRow.toString() + nextPossibleCol.toString();\n    // if (!typeOfSquare !== \"knight\") {\n    //   console.log(nextPossibleCell);\n    //   if (mapObj[nextPossibleCell].player !== player) {\n    //     // figure that is not a knight cant jump over figures\n    //     return;\n    //   }\n    // }\n    if (!mapObj[nextPossibleCell]) {\n      return (nextPossibleMoves[nextPossibleCell] = \"empty\");\n    } else if (mapObj[nextPossibleCell].player !== player) {\n      return (nextPossibleMoves[nextPossibleCell] = \"eat\");\n    } else return {};\n  };\n\n  const findPath = (fromSquare) => {\n    let nextPossibleMoves = {};\n    if (!fromSquare) {\n      return {};\n    } else if (!mapObj[fromSquare]) {\n      return {};\n    }\n    const [moveFromRow, moveFromCol] = parseToNumber(fromSquare);\n    const bishopFunctionInfo = (i) => {\n      addPossibleCellToPath(\n        fromSquare,\n        moveFromRow + i,\n        moveFromCol + i,\n        nextPossibleMoves\n      );\n      addPossibleCellToPath(\n        fromSquare,\n        moveFromRow - i,\n        moveFromCol - i,\n        nextPossibleMoves\n      );\n      addPossibleCellToPath(\n        fromSquare,\n        moveFromRow + i,\n        moveFromCol - i,\n        nextPossibleMoves\n      );\n      addPossibleCellToPath(\n        fromSquare,\n        moveFromRow - i,\n        moveFromCol + i,\n        nextPossibleMoves\n      );\n    };\n    const pawnFunctionInfo = () => {\n      addPossibleCellToPath(\n        fromSquare,\n        moveFromRow - 1,\n        moveFromCol,\n        nextPossibleMoves\n      );\n      addPossibleCellToPath(\n        fromSquare,\n        moveFromRow + 1,\n        moveFromCol,\n        nextPossibleMoves\n      );\n    };\n    if (mapObj[fromSquare].type === \"pawn\") {\n      const fromSquareToNum = Number(fromSquare);\n      const getNextPawnMove = () => {\n        if (mapObj[fromSquare].player === false) {\n          if (fromSquare[0] === \"1\") {\n            //if its first move, pawn can move 2 squares\n            addPossibleCellToPath(\n              fromSquare,\n              moveFromRow + 2,\n              moveFromCol,\n              nextPossibleMoves\n            );\n            addPossibleCellToPath(\n              fromSquare,\n              moveFromRow + 1,\n              moveFromCol,\n              nextPossibleMoves\n            );\n            return nextPossibleMoves;\n          }\n          if (mapObj[(fromSquareToNum + 11).toString()]) {\n            //check if the pawn my eat\n            if (\n              mapObj[(fromSquareToNum + 11).toString()].player !==\n              mapObj[fromSquare].player\n            ) {\n              addPossibleCellToPath(\n                fromSquare,\n                moveFromRow + 1,\n                moveFromCol + 1,\n                nextPossibleMoves\n              );\n            }\n          }\n        }\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow + 1,\n          moveFromCol,\n          nextPossibleMoves\n        );\n        console.log(nextPossibleMoves);\n        if (mapObj[fromSquare].player === true) {\n          if (fromSquare[0] === \"6\") {\n            //if its first move, pawn can move 2 squares\n            addPossibleCellToPath(\n              fromSquare,\n              moveFromRow - 2,\n              moveFromCol,\n              nextPossibleMoves\n            );\n            addPossibleCellToPath(\n              fromSquare,\n              moveFromRow - 1,\n              moveFromCol,\n              nextPossibleMoves\n            );\n            return nextPossibleMoves;\n          }\n          addPossibleCellToPath(\n            fromSquare,\n            moveFromRow - 1,\n            moveFromCol,\n            nextPossibleMoves\n          );\n          if (mapObj[(fromSquareToNum - 11).toString()]) {\n            //check if the pawn may eat\n            if (\n              mapObj[(fromSquareToNum - 11).toString()].player !==\n              mapObj[fromSquare].player\n            ) {\n              addPossibleCellToPath(\n                fromSquare,\n                moveFromRow - 1,\n                moveFromCol - 1,\n                nextPossibleMoves\n              );\n            }\n          }\n        }\n        pawnFunctionInfo();\n        return nextPossibleMoves;\n      };\n      const result = getNextPawnMove(fromSquare);\n\n      console.log(\"kkk\", result);\n      return result;\n    }\n    // console.log(fromSquare, mapObj);\n    if (mapObj[fromSquare].type === \"knight\") {\n      const getNextKnightMove = () => {\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow - 2,\n          moveFromCol + 1,\n          nextPossibleMoves\n        );\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow - 2,\n          moveFromCol - 1,\n          nextPossibleMoves\n        );\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow + 2,\n          moveFromCol + 1,\n          nextPossibleMoves\n        );\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow + 2,\n          moveFromCol - 1,\n          nextPossibleMoves\n        );\n\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow - 1,\n          moveFromCol + 2,\n          nextPossibleMoves\n        );\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow - 1,\n          moveFromCol - 2,\n          nextPossibleMoves\n        );\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow + 1,\n          moveFromCol + 2,\n          nextPossibleMoves\n        );\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow + 1,\n          moveFromCol - 2,\n          nextPossibleMoves\n        );\n        return nextPossibleMoves;\n      };\n      const result = getNextKnightMove(fromSquare);\n\n      console.log(\"kkk\", result);\n      return result;\n    }\n    if (mapObj[fromSquare].type === \"bishop\") {\n      const getNextBishopMove = () => {\n        for (let i = fromSquare[0]; i <= 7; i++) {\n          bishopFunctionInfo(i);\n        }\n        for (let i = fromSquare[0]; i >= 0; i--) {\n          bishopFunctionInfo(i);\n        }\n        return nextPossibleMoves;\n      };\n      const result = getNextBishopMove(fromSquare);\n\n      console.log(\"kkk\", result);\n      return result;\n    }\n    if (mapObj[fromSquare].type === \"queen\") {\n      const getNextQueenMove = () => {\n        for (let i = 1; i <= 7; i++) {\n          bishopFunctionInfo(i);\n        }\n        return nextPossibleMoves;\n      };\n      const result = getNextQueenMove(fromSquare);\n\n      console.log(\"kkk\", result);\n      return result;\n    }\n    if (mapObj[fromSquare].type === \"king\") {\n      const getNextKingMove = () => {\n        pawnFunctionInfo();\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow + 1,\n          moveFromCol - 1,\n          nextPossibleMoves\n        );\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow + 1,\n          moveFromCol + 1,\n          nextPossibleMoves\n        );\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow,\n          moveFromCol - 1,\n          nextPossibleMoves\n        );\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow,\n          moveFromCol + 1,\n          nextPossibleMoves\n        );\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow - 1,\n          moveFromCol - 1,\n          nextPossibleMoves\n        );\n        addPossibleCellToPath(\n          fromSquare,\n          moveFromRow - 1,\n          moveFromCol + 1,\n          nextPossibleMoves\n        );\n        return nextPossibleMoves;\n      };\n      const result = getNextKingMove(fromSquare);\n\n      console.log(\"kkk\", result);\n      return result;\n    }\n    if (mapObj[fromSquare].type === \"rook\") {\n      console.log(\"rooked\");\n\n      // get's the square (index) of the square above the given  index\n      const getSquareAbove = (square) => {\n        //getting the string square and return the next square going up as a number\n        const squareNum = Number(square);\n        return squareNum - 10;\n      };\n      const getSquareDown = (square) => {\n        //getting the string square and return the next square going down as a number\n        const squareNum = Number(square);\n        return squareNum + 10;\n      };\n      const getSquareLeft = (square) => {\n        //getting the string square and return the next square going left as a number\n        const squareNum = Number(square);\n        return squareNum - 1;\n      };\n      // const getSquareRight = (square) => {\n      //   //getting the string square and return the next square going right as a number\n      //   const squareNum = Number(square);\n      //   return squareNum + 1;\n      // };\n      const movableSquaresAbove = findMovableSquaresInDirection({\n        startingSquare: fromSquare,\n        getNextSquareFn: getSquareAbove,\n        mapObj,\n      });\n      const movableSquaresDown = findMovableSquaresInDirection({\n        startingSquare: fromSquare,\n        getNextSquareFn: getSquareDown,\n        mapObj,\n      });\n      const movableSquaresLeft = findMovableSquaresInDirection({\n        startingSquare: fromSquare,\n        getNextSquareFn: getSquareLeft,\n        mapObj,\n      });\n\n      console.log(\"kkk\", movableSquaresAbove);\n      console.log(\"kkk\", movableSquaresDown);\n      return {\n        ...movableSquaresAbove,\n        ...movableSquaresDown,\n        ...movableSquaresLeft,\n      };\n    }\n  };\n  const handleClick = (con) => {\n    if (count === 0) {\n      if (!mapObj[con]) {\n        //first spuare to click cant be empty\n        return;\n      }\n    }\n    if (count === 0) {\n      setFromSquare(con);\n      setCount(count + 1);\n      console.log(\"this con mada\", con);\n      setChosen(con);\n      console.log(\"chosen:\", chosen);\n      return;\n    }\n    //second click\n    // fromSquare -> toSqaure\n    if (!mapObj[con] || mapObj[fromSquare].player !== mapObj[con].player) {\n      // check if the square we move to is empty or filled with the other player\n      const moveFigureFromSquareToSquare = (fromSquare, con) => {\n        // console.log(\"out here checkin\", fromSquare, con);\n        if (findPath(fromSquare)[con]) {\n          //check if the second click is in path => can move\n          const returnPathArr = Object.values(findPath(fromSquare));\n          for (let i = 0; i <= returnPathArr.length; i++) {\n            // console.log(\"im fromsquare:\", fromSquare);\n            // console.log(\"im the fucking return array:\", returnPathArr);\n            //scan through path and not let passing through NON-EMPTY\n            if (returnPathArr[i] === \"empty\" || returnPathArr[i] === \"eat\") {\n              // if the square is empty or eatable you may move\n              // console.log(\"i survived\");\n              moveInvoke(fromSquare, con);\n              setCount(0);\n              return;\n            }\n            return;\n          }\n        }\n      };\n      moveFigureFromSquareToSquare(fromSquare, con);\n    }\n    setCount(0);\n  };\n\n  console.log(chosen);\n  const path = findPath(chosen);\n  console.log(path);\n\n  return (\n    // we will map 8 * 8 of arrays to build our board.\n    <div>\n      {Array(8)\n        .fill(0)\n        .map((e, rowIndex) => {\n          return (\n            <div\n              style={{\n                display: \"flex\",\n                flexDirection: \"row\",\n              }}\n            >\n              {Array(8)\n                .fill(0)\n                .map((e, squareIndex) => {\n                  const colorPic =\n                    (squareIndex + rowIndex) % 2 === 0 ? true : false;\n                  // we will caculate the spread of black & white color on the board and identify each square\n                  const numRow = rowIndex.toString();\n                  const numSquare = squareIndex.toString();\n                  const con = numRow.concat(numSquare);\n                  const piece = mapObj[con];\n                  const isHighlighted = path[con] ? true : false;\n                  console.log(isHighlighted);\n                  return (\n                    //props\n                    <Square\n                      isHighlighted={isHighlighted}\n                      color={colorPic}\n                      piece={piece}\n                      onClick={() => handleClick(con)}\n\n                      // onMouseOver={() => handleMouseOver(colorPic)}\n                    />\n                  );\n                })}\n            </div>\n          );\n        })}\n      <h1>{printCheckOutside}</h1>\n      <h1>{printPlayerOutside}</h1>\n    </div>\n  );\n};\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Board />\n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}