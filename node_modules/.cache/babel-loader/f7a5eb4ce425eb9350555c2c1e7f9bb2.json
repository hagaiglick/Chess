{"ast":null,"code":"export function findMovableSquaresInDirection({\n  startingSquare,\n  getNextSquareFn,\n  mapObj\n}) {\n  let currentlyCheckedSquare = startingSquare;\n  let movableSquares = {};\n  const player = mapObj[startingSquare].player;\n\n  const isSquareInsideBoard = square => Number(square) >= 0 && Number(square) <= 77;\n\n  while (isSquareInsideBoard(currentlyCheckedSquare)) {\n    // advance one square each iteration (note that the starting square is not a square you can move into)\n    currentlyCheckedSquare = getNextSquareFn(currentlyCheckedSquare);\n    const squareContent = mapObj[currentlyCheckedSquare]; // if square is empty, add it as movable and advance one square\n\n    if (!squareContent) {\n      if (currentlyCheckedSquare.length === 1) {\n        console.log(\"is one\");\n        currentlyCheckedSquare = \"0\" + currentlyCheckedSquare;\n        movableSquares[currentlyCheckedSquare] = \"empty\";\n\n        if (currentlyCheckedSquare.length > 1) {\n          console.log(\"is more than one\");\n          movableSquares[currentlyCheckedSquare] = \"empty\";\n        }\n      }\n    } // if last square is occupied by opponent's piece, the square is movable as the piece can be taken\n    else if (squareContent.player !== player) {\n        movableSquares[startingSquare] = mapObj[startingSquare];\n        break;\n      } // Square is not empty, nor taken by an opponent's piece\n      else {\n          break;\n        }\n  }\n\n  return movableSquares;\n}","map":{"version":3,"sources":["/Users/mac/Chess/src/findMovableSquares.js"],"names":["findMovableSquaresInDirection","startingSquare","getNextSquareFn","mapObj","currentlyCheckedSquare","movableSquares","player","isSquareInsideBoard","square","Number","squareContent","length","console","log"],"mappings":"AAAA,OAAO,SAASA,6BAAT,CAAuC;AAC5CC,EAAAA,cAD4C;AAE5CC,EAAAA,eAF4C;AAG5CC,EAAAA;AAH4C,CAAvC,EAIJ;AACD,MAAIC,sBAAsB,GAAGH,cAA7B;AACA,MAAII,cAAc,GAAG,EAArB;AACA,QAAMC,MAAM,GAAGH,MAAM,CAACF,cAAD,CAAN,CAAuBK,MAAtC;;AACA,QAAMC,mBAAmB,GAAIC,MAAD,IAC1BC,MAAM,CAACD,MAAD,CAAN,IAAkB,CAAlB,IAAuBC,MAAM,CAACD,MAAD,CAAN,IAAkB,EAD3C;;AAGA,SAAOD,mBAAmB,CAACH,sBAAD,CAA1B,EAAoD;AAClD;AACAA,IAAAA,sBAAsB,GAAGF,eAAe,CAACE,sBAAD,CAAxC;AACA,UAAMM,aAAa,GAAGP,MAAM,CAACC,sBAAD,CAA5B,CAHkD,CAIlD;;AACA,QAAI,CAACM,aAAL,EAAoB;AAClB,UAAIN,sBAAsB,CAACO,MAAvB,KAAkC,CAAtC,EAAyC;AACvCC,QAAAA,OAAO,CAACC,GAAR,CAAY,QAAZ;AACAT,QAAAA,sBAAsB,GAAG,MAAMA,sBAA/B;AACAC,QAAAA,cAAc,CAACD,sBAAD,CAAd,GAAyC,OAAzC;;AACA,YAAIA,sBAAsB,CAACO,MAAvB,GAAgC,CAApC,EAAuC;AACrCC,UAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ;AACAR,UAAAA,cAAc,CAACD,sBAAD,CAAd,GAAyC,OAAzC;AACD;AACF;AACF,KAVD,CAWA;AAXA,SAYK,IAAIM,aAAa,CAACJ,MAAd,KAAyBA,MAA7B,EAAqC;AACxCD,QAAAA,cAAc,CAACJ,cAAD,CAAd,GAAiCE,MAAM,CAACF,cAAD,CAAvC;AACA;AACD,OAHI,CAIL;AAJK,WAKA;AACH;AACD;AACF;;AAED,SAAOI,cAAP;AACD","sourcesContent":["export function findMovableSquaresInDirection({\n  startingSquare,\n  getNextSquareFn,\n  mapObj,\n}) {\n  let currentlyCheckedSquare = startingSquare;\n  let movableSquares = {};\n  const player = mapObj[startingSquare].player;\n  const isSquareInsideBoard = (square) =>\n    Number(square) >= 0 && Number(square) <= 77;\n\n  while (isSquareInsideBoard(currentlyCheckedSquare)) {\n    // advance one square each iteration (note that the starting square is not a square you can move into)\n    currentlyCheckedSquare = getNextSquareFn(currentlyCheckedSquare);\n    const squareContent = mapObj[currentlyCheckedSquare];\n    // if square is empty, add it as movable and advance one square\n    if (!squareContent) {\n      if (currentlyCheckedSquare.length === 1) {\n        console.log(\"is one\");\n        currentlyCheckedSquare = \"0\" + currentlyCheckedSquare;\n        movableSquares[currentlyCheckedSquare] = \"empty\";\n        if (currentlyCheckedSquare.length > 1) {\n          console.log(\"is more than one\");\n          movableSquares[currentlyCheckedSquare] = \"empty\";\n        }\n      }\n    }\n    // if last square is occupied by opponent's piece, the square is movable as the piece can be taken\n    else if (squareContent.player !== player) {\n      movableSquares[startingSquare] = mapObj[startingSquare];\n      break;\n    }\n    // Square is not empty, nor taken by an opponent's piece\n    else {\n      break;\n    }\n  }\n\n  return movableSquares;\n}\n"]},"metadata":{},"sourceType":"module"}