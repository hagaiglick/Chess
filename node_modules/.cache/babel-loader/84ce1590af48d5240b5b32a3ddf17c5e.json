{"ast":null,"code":"export function findMovableSquaresInDirection({\n  startingSquare,\n  getNextSquareFn,\n  mapObj\n}) {\n  let currentlyCheckedSquare = startingSquare;\n  let movableSquares = [];\n  const player = mapObj[startingSquare].player;\n\n  const isSquareInsideBoard = square => Number(square) >= 0 && Number(square) <= 77;\n\n  while (isSquareInsideBoard(currentlyCheckedSquare)) {\n    // advance one square each iteration (note that the starting square is not a square you can move into)\n    currentlyCheckedSquare = getNextSquareFn(currentlyCheckedSquare);\n    const squareContent = mapObj[currentlyCheckedSquare]; // if square is empty, add it as movable and advance one square\n\n    if (!squareContent) {\n      movableSquares.push(mapObj[currentlyCheckedSquare]);\n    } // if last square is occupied by opponent's piece, the square is movable as the piece can be taken\n    else if (squareContent.player !== player) {\n        movableSquares.push(startingSquare);\n        break;\n      } // Square is not empty, nor taken by an opponent's piece\n      else {\n          break;\n        }\n  }\n\n  return movableSquares;\n}","map":{"version":3,"sources":["/Users/mac/Chess/src/findMovableSquares.js"],"names":["findMovableSquaresInDirection","startingSquare","getNextSquareFn","mapObj","currentlyCheckedSquare","movableSquares","player","isSquareInsideBoard","square","Number","squareContent","push"],"mappings":"AAAA,OAAO,SAASA,6BAAT,CAAuC;AAC5CC,EAAAA,cAD4C;AAE5CC,EAAAA,eAF4C;AAG5CC,EAAAA;AAH4C,CAAvC,EAIJ;AACD,MAAIC,sBAAsB,GAAGH,cAA7B;AACA,MAAII,cAAc,GAAG,EAArB;AACA,QAAMC,MAAM,GAAGH,MAAM,CAACF,cAAD,CAAN,CAAuBK,MAAtC;;AACA,QAAMC,mBAAmB,GAAIC,MAAD,IAC1BC,MAAM,CAACD,MAAD,CAAN,IAAkB,CAAlB,IAAuBC,MAAM,CAACD,MAAD,CAAN,IAAkB,EAD3C;;AAGA,SAAOD,mBAAmB,CAACH,sBAAD,CAA1B,EAAoD;AAClD;AACAA,IAAAA,sBAAsB,GAAGF,eAAe,CAACE,sBAAD,CAAxC;AACA,UAAMM,aAAa,GAAGP,MAAM,CAACC,sBAAD,CAA5B,CAHkD,CAIlD;;AACA,QAAI,CAACM,aAAL,EAAoB;AAClBL,MAAAA,cAAc,CAACM,IAAf,CAAoBR,MAAM,CAACC,sBAAD,CAA1B;AACD,KAFD,CAGA;AAHA,SAIK,IAAIM,aAAa,CAACJ,MAAd,KAAyBA,MAA7B,EAAqC;AACxCD,QAAAA,cAAc,CAACM,IAAf,CAAoBV,cAApB;AACA;AACD,OAHI,CAIL;AAJK,WAKA;AACH;AACD;AACF;;AAED,SAAOI,cAAP;AACD","sourcesContent":["export function findMovableSquaresInDirection({\n  startingSquare,\n  getNextSquareFn,\n  mapObj,\n}) {\n  let currentlyCheckedSquare = startingSquare;\n  let movableSquares = [];\n  const player = mapObj[startingSquare].player;\n  const isSquareInsideBoard = (square) =>\n    Number(square) >= 0 && Number(square) <= 77;\n\n  while (isSquareInsideBoard(currentlyCheckedSquare)) {\n    // advance one square each iteration (note that the starting square is not a square you can move into)\n    currentlyCheckedSquare = getNextSquareFn(currentlyCheckedSquare);\n    const squareContent = mapObj[currentlyCheckedSquare];\n    // if square is empty, add it as movable and advance one square\n    if (!squareContent) {\n      movableSquares.push(mapObj[currentlyCheckedSquare]);\n    }\n    // if last square is occupied by opponent's piece, the square is movable as the piece can be taken\n    else if (squareContent.player !== player) {\n      movableSquares.push(startingSquare);\n      break;\n    }\n    // Square is not empty, nor taken by an opponent's piece\n    else {\n      break;\n    }\n  }\n\n  return movableSquares;\n}\n"]},"metadata":{},"sourceType":"module"}