{"ast":null,"code":"export function findMovableSquaresInDirection({\n  startingSquare,\n  getNextSqureFn,\n  mapObj\n}) {\n  let currentlyCheckedSquare = startingSquare;\n  let movableSquares = [];\n  const player = mapObj[startingSquare].player;\n\n  const isSquareInsideBoard = square => Number(square) >= 0 && Number(square) <= 77;\n\n  while (isSquareInsideBoard(currentlyCheckedSquare)) {\n    // advance one square each iteration (note that the starting square is not a square you can move into)\n    currentlyCheckedSquare = getNextSqureFn(currentlyCheckedSquare);\n    const squareContent = mapObj[currentlyCheckedSquare]; // if square is empty, add it as movable and advance one square\n\n    if (squareContent.type === \"empty\") {\n      movableSquares.push(currentlyCheckedSquare);\n    } // if last square is occupied by opponent's piece, the square is movable as the piece can be taken\n    else if (squreContent.player !== player) {\n        movableSquares.push(square);\n        break;\n      } // Square is not empty, nor taken by an opponent's piece\n      else {\n          break;\n        }\n  }\n\n  return movableSquares;\n}","map":{"version":3,"sources":["/Users/mac/Chess/src/findMovableSquares.js"],"names":["findMovableSquaresInDirection","startingSquare","getNextSqureFn","mapObj","currentlyCheckedSquare","movableSquares","player","isSquareInsideBoard","square","Number","squareContent","type","push","squreContent"],"mappings":"AAAA,OAAO,SAASA,6BAAT,CAAuC;AAC5CC,EAAAA,cAD4C;AAE5CC,EAAAA,cAF4C;AAG5CC,EAAAA;AAH4C,CAAvC,EAIJ;AACD,MAAIC,sBAAsB,GAAGH,cAA7B;AACA,MAAII,cAAc,GAAG,EAArB;AACA,QAAMC,MAAM,GAAGH,MAAM,CAACF,cAAD,CAAN,CAAuBK,MAAtC;;AACA,QAAMC,mBAAmB,GAAIC,MAAD,IAC1BC,MAAM,CAACD,MAAD,CAAN,IAAkB,CAAlB,IAAuBC,MAAM,CAACD,MAAD,CAAN,IAAkB,EAD3C;;AAGA,SAAOD,mBAAmB,CAACH,sBAAD,CAA1B,EAAoD;AAClD;AACAA,IAAAA,sBAAsB,GAAGF,cAAc,CAACE,sBAAD,CAAvC;AACA,UAAMM,aAAa,GAAGP,MAAM,CAACC,sBAAD,CAA5B,CAHkD,CAIlD;;AACA,QAAIM,aAAa,CAACC,IAAd,KAAuB,OAA3B,EAAoC;AAClCN,MAAAA,cAAc,CAACO,IAAf,CAAoBR,sBAApB;AACD,KAFD,CAGA;AAHA,SAIK,IAAIS,YAAY,CAACP,MAAb,KAAwBA,MAA5B,EAAoC;AACvCD,QAAAA,cAAc,CAACO,IAAf,CAAoBJ,MAApB;AACA;AACD,OAHI,CAIL;AAJK,WAKA;AACH;AACD;AACF;;AAED,SAAOH,cAAP;AACD","sourcesContent":["export function findMovableSquaresInDirection({\n  startingSquare,\n  getNextSqureFn,\n  mapObj,\n}) {\n  let currentlyCheckedSquare = startingSquare;\n  let movableSquares = [];\n  const player = mapObj[startingSquare].player;\n  const isSquareInsideBoard = (square) =>\n    Number(square) >= 0 && Number(square) <= 77;\n\n  while (isSquareInsideBoard(currentlyCheckedSquare)) {\n    // advance one square each iteration (note that the starting square is not a square you can move into)\n    currentlyCheckedSquare = getNextSqureFn(currentlyCheckedSquare);\n    const squareContent = mapObj[currentlyCheckedSquare];\n    // if square is empty, add it as movable and advance one square\n    if (squareContent.type === \"empty\") {\n      movableSquares.push(currentlyCheckedSquare);\n    }\n    // if last square is occupied by opponent's piece, the square is movable as the piece can be taken\n    else if (squreContent.player !== player) {\n      movableSquares.push(square);\n      break;\n    }\n    // Square is not empty, nor taken by an opponent's piece\n    else {\n      break;\n    }\n  }\n\n  return movableSquares;\n}\n"]},"metadata":{},"sourceType":"module"}