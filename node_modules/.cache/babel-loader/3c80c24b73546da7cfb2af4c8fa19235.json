{"ast":null,"code":"var _jsxFileName = \"/Users/mac/Chess/src/App.js\";\nimport React, { useState, useEffect } from \"react\"; // import logo from \"./logo.svg\";\n\nimport \"./App.css\";\nimport Square from \"./Square\"; // import styled from \"styled-components\";\n// fromSquare \"10\"\n// toSquare \"21\"\n// mapObj\n// 2. mapObj[toSquare] = mapObj[fromSquare] to the obj\n// 1. delete the property whose key is \"fromSquare\" from mapObj\n// const Div = styled.div({\n//   background: \"yellow\",\n//   opacity: \"1\",\n//   \":hover\": {\n//     background: \"red\",\n//   },\n// });\n\nconst mapObj = {\n  //database of the board\n  \"00\": {\n    type: \"rook\",\n    player: false\n  },\n  \"01\": {\n    type: \"knight\",\n    player: false\n  },\n  \"02\": {\n    type: \"bishop\",\n    player: false\n  },\n  \"03\": {\n    type: \"king\",\n    player: false\n  },\n  \"04\": {\n    type: \"queen\",\n    player: false\n  },\n  \"05\": {\n    type: \"bishop\",\n    player: false\n  },\n  \"06\": {\n    type: \"knight\",\n    player: false\n  },\n  \"07\": {\n    type: \"rook\",\n    player: false\n  },\n  \"10\": {\n    type: \"pawn\",\n    player: false\n  },\n  \"11\": {\n    type: \"pawn\",\n    player: false\n  },\n  \"12\": {\n    type: \"pawn\",\n    player: false\n  },\n  \"13\": {\n    type: \"pawn\",\n    player: false\n  },\n  \"14\": {\n    type: \"pawn\",\n    player: false\n  },\n  \"15\": {\n    type: \"pawn\",\n    player: false\n  },\n  \"16\": {\n    type: \"pawn\",\n    player: false\n  },\n  \"17\": {\n    type: \"pawn\",\n    player: false\n  },\n  \"60\": {\n    type: \"pawn\",\n    player: true\n  },\n  \"61\": {\n    type: \"pawn\",\n    player: true\n  },\n  \"62\": {\n    type: \"pawn\",\n    player: true\n  },\n  \"63\": {\n    type: \"pawn\",\n    player: true\n  },\n  \"64\": {\n    type: \"pawn\",\n    player: true\n  },\n  \"65\": {\n    type: \"pawn\",\n    player: true\n  },\n  \"66\": {\n    type: \"pawn\",\n    player: true\n  },\n  \"67\": {\n    type: \"pawn\",\n    player: true\n  },\n  \"70\": {\n    type: \"rook\",\n    player: true\n  },\n  \"71\": {\n    type: \"knight\",\n    player: true\n  },\n  \"72\": {\n    type: \"bishop\",\n    player: true\n  },\n  \"73\": {\n    type: \"king\",\n    player: true\n  },\n  \"74\": {\n    type: \"queen\",\n    player: true\n  },\n  \"75\": {\n    type: \"bishop\",\n    player: true\n  },\n  \"76\": {\n    type: \"knight\",\n    player: true\n  },\n  \"77\": {\n    type: \"rook\",\n    player: true\n  }\n};\n\nconst Board = () => {\n  const [count, setCount] = useState(0);\n  const [fromSquare, setFromSquare] = useState();\n  const [player, setPlayer] = useState(true);\n  const [check, setCheck] = useState(false);\n  const [chosen, setChosen] = useState(); // const [toSquare, setToSquare] = useState();\n  // useEffect(() => {\n  //   if (check === true) {\n  //     console.log(\"check is true\");\n  //     setCount(0);\n  //   }\n  // }, 1);\n\n  console.log(chosen);\n  let printCheckOutside;\n  let printPlayerOutside;\n\n  const printCheck = check => {\n    check === false ? printCheckOutside = \"no check at this point\" : printCheckOutside = \"check, please protect your King\";\n  };\n\n  const printPlayer = player => {\n    player === true ? printPlayerOutside = \"white player's turn\" : printPlayerOutside = \"blue player's turn\";\n  };\n\n  printCheck(check);\n  printPlayer(player);\n\n  const moveInvoke = (moveFrom, moveTo) => {\n    // the actual movePiece\n    movePiece(moveFrom, moveTo);\n  };\n\n  check === false ? console.log(\"check false\") : console.log(\"check truth\"); // checking if theres a check in play\n\n  const findKing = startingSquare => {\n    // here we find the king's key (location)\n    const entries = Object.entries(mapObj); // console.log(entries);\n\n    for (let i = 0; i <= entries.length - 1; i++) {\n      let kingIndex;\n\n      if (entries[i][1].type === \"king\") {\n        if (entries[i][1].player !== mapObj[startingSquare].player) {\n          kingIndex = entries[i][0];\n          console.log(\"insideFindKing:\", kingIndex);\n          return kingIndex;\n        }\n      }\n    }\n  }; // useState chosen\n  // caculate which cells i chose and which will be on my path\n  // scan through the cells and paint the chosen\n  // const getTheFigurePath = (moveFrom, moveTo) => {\n  //   const path = [];\n  //   let passingSquare;\n  //   const [moveFromRow, moveFromCol] = splitAndParseToNumber(moveFrom);\n  //   const [moveToRow, moveToCol] = splitAndParseToNumber(moveTo);\n  //   let j = moveFromCol;\n  //   //fill the path with the squares we past\n  //   //check witch is bigger , the rows move from or rows move to . if moveTo rows? then we going down, else going up\n  //   //check the going up movements:TODO - SET IN A OTHER FUNCTION ?\n  //   if (moveFromRow > moveToRow) {\n  //     //going only up the board\n  //     if (moveFromCol === moveToCol) {\n  //       for (let i = moveFromRow; i >= moveToRow; i--) {\n  //         passingSquare = i.toString() + moveFromCol.toString();\n  //         path.push(passingSquare);\n  //       }\n  //     }\n  //     //going up and move left\n  //     else if (moveFromCol > moveToCol) {\n  //       for (let i = moveFromRow; i > moveToRow; i--) {\n  //         passingSquare = i.toString() + j.toString();\n  //         path.push(passingSquare);\n  //         if (j >= moveToCol) j--;\n  //       }\n  //       path.push(moveTo);\n  //     }\n  //     //move up and turn right\n  //     else if (moveFromCol < moveToCol) {\n  //       for (let i = moveFromRow; i >= moveToRow; i--) {\n  //         passingSquare = i.toString() + j.toString();\n  //         path.push(passingSquare);\n  //         if (j <= moveToCol) j++;\n  //       }\n  //       path.push(moveTo);\n  //     }\n  //   }\n  //   // Check for the going down movements:\n  //   else {\n  //     //only goes down:\n  //     if (moveFromCol === moveToCol) {\n  //       for (let i = moveFromRow; i <= moveToRow; i++) {\n  //         passingSquare = i.toString() + moveToCol.toString();\n  //         path.push(passingSquare);\n  //       }\n  //       //goes down and right\n  //     } else if (moveFromCol < moveToCol) {\n  //       for (let i = moveFromRow; i <= moveToRow; i++) {\n  //         passingSquare = i.toString() + j.toString();\n  //         path.push(passingSquare);\n  //         if (j <= moveToCol) j++;\n  //       }\n  //       //goes down and left\n  //     } else {\n  //       for (let i = moveFromRow; i <= moveToRow; i++) {\n  //         passingSquare = i.toString() + j.toString();\n  //         if (j >= moveToCol) j--;\n  //       }\n  //     }\n  //   }\n  //   return path;\n  // };\n  // const movePawn = (fromMove, toMove) => {\n  //   // console.log(mapObj[fromSquare].player);\n  //   if (mapObj[fromSquare].player === false) {\n  //     // if the pawn is black or white he can go to certain direction and eat a certain way\n  //     //only the pawns first step may be two steps\n  //     if (fromMove[0] - toMove[0] === -2) {\n  //       //only if its the pawn first move it can go two steps\n  //       if (fromMove[0] === \"1\") {\n  //         return moveInvoke(fromSquare, toMove);\n  //       }\n  //     }\n  //     if (fromMove[0] - toMove[0] === -1) {\n  //       //normally a pawn can only go straight\n  //       if (fromMove[1] - toMove[1] === 0) {\n  //         if (!mapObj[toMove]) {\n  //           return moveInvoke(fromSquare, toMove);\n  //         }\n  //       } else if (\n  //         fromMove[1] - toMove[1] === 1 ||\n  //         fromMove[1] - toMove[1] === -1\n  //       ) {\n  //         // in case of eating\n  //         if (!mapObj[toMove]) {\n  //           return;\n  //         } else if (mapObj[fromSquare] !== mapObj[toMove]) {\n  //           return moveInvoke(fromSquare, toMove);\n  //         }\n  //       }\n  //     }\n  //   }\n  //   if (mapObj[fromSquare].player === true) {\n  //     if (fromMove[0] - toMove[0] === 2) {\n  //       //only if its the pawn first move it can go two steps\n  //       if (fromMove[0] === \"6\") {\n  //         return moveInvoke(fromSquare, toMove);\n  //       }\n  //     }\n  //     //case of white pawn go straight\n  //     if (fromMove[0] - toMove[0] === 1) {\n  //       if (fromMove[1] - toMove[1] === 0) {\n  //         if (!mapObj[toMove]) {\n  //           return moveInvoke(fromSquare, toMove);\n  //         }\n  //       } else if (\n  //         fromMove[1] - toMove[1] === 1 ||\n  //         fromMove[1] - toMove[1] === -1\n  //       ) {\n  //         //in case of eating\n  //         if (!mapObj[toMove]) {\n  //           return;\n  //         } else if (mapObj[fromSquare] !== mapObj[toMove]) {\n  //           return moveInvoke(fromSquare, toMove);\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return console.log(\"nah\");\n  // };\n  // const moveRook = (fromMove, con) => {\n  //   // rook can only move straight up\\down or straight left\\right\n  //   const fromToZeroIndex = fromMove[0] - con[0];\n  //   const fromToOneIndex = fromMove[1] - con[1];\n  //   if (fromToZeroIndex <= 7 || fromToZeroIndex >= -7) {\n  //     if (fromToOneIndex === 0) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  //   if (fromMove[0] - con[0] === 0) {\n  //     if (fromToOneIndex <= 7 || fromToOneIndex >= -7) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  // };\n  // const moveKnight = (fromMove, con) => {\n  //   // knight logic. if it moves 1 further, it means 2 to the side, if 2 further, 1 to the side.\n  //   const fromToZeroIndex = fromMove[0] - con[0];\n  //   const fromToOneIndex = fromMove[1] - con[1];\n  //   if (fromToZeroIndex === 1 || fromToZeroIndex === -1) {\n  //     if (fromToOneIndex === -2 || fromToOneIndex === 2) {\n  //       return moveInvoke(fromMove, con);\n  //     }\n  //   } else if (fromToZeroIndex === 2 || fromToZeroIndex === -2) {\n  //     if (fromToOneIndex === 1 || fromToOneIndex === -1) {\n  //       return moveInvoke(fromMove, con);\n  //     }\n  //   }\n  // };\n  // const moveBishop = (fromMove, con) => {\n  //   // bishop can only move at an angle on its same color.\n  //   const fromToZeroIndex = fromMove[0] - con[0];\n  //   const fromToOneIndex = fromMove[1] - con[1];\n  //   let i = fromToZeroIndex;\n  //   if (fromToZeroIndex === i || fromToZeroIndex === -i) {\n  //     if (fromToOneIndex === i || fromToOneIndex === -i) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  // };\n  // const moveQueen = (fromMove, con) => {\n  //   // can behave as any other piece apart from knight.\n  //   const fromToZeroIndex = fromMove[0] - con[0];\n  //   const fromToOneIndex = fromMove[1] - con[1];\n  //   let i = fromToZeroIndex;\n  //   if (\n  //     fromToZeroIndex === i ||\n  //     fromToZeroIndex === -i ||\n  //     fromToZeroIndex === 0\n  //   ) {\n  //     if (\n  //       fromToOneIndex === i ||\n  //       fromToOneIndex === -i ||\n  //       fromToOneIndex === 0\n  //     ) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  //   if (fromMove[0] - con[0] === 0) {\n  //     if (fromToOneIndex <= 7 || fromToOneIndex >= -7) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  //   return console.log(\"nah\");\n  // };\n  // const moveKing = (fromMove, con) => {\n  //   const fromToZeroIndex = fromMove[0] - con[0];\n  //   const fromToOneIndex = fromMove[1] - con[1];\n  //   if (\n  //     fromToZeroIndex === 1 ||\n  //     fromToZeroIndex === 0 ||\n  //     fromToZeroIndex === -1\n  //   ) {\n  //     if (\n  //       fromToOneIndex === 1 ||\n  //       fromToOneIndex === 0 ||\n  //       fromToOneIndex === -1\n  //     ) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  //   return console.log(\"nah\");\n  // };\n  // const checkPath = (path) => {\n  //   //get an path array\n  //   for (let i = 1; i <= path.length; i++) {\n  //     let figure = path[i];\n  //     if (mapObj[figure]) {\n  //       // console.log(\"figured\");\n  //       // console.log(mapObj[path[0]].type);\n  //       if (mapObj[path[0]].type == \"knight\") {\n  //         return true;\n  //       }\n  //     }\n  //     if (mapObj[figure]) return false;\n  //     if (i === path.length - 1) {\n  //       if (mapObj[figure]) {\n  //         if (mapObj[figure].player !== mapObj[figure].player) {\n  //           return false;\n  //         }\n  //       }\n  //     }\n  //     //if last cell is empty ?\n  //     // if the last cell is the same color as the current player\n  //     //if the last cell is the other color\n  //     //last cell.\n  //   }\n  //   return true;\n  //   // return printCheckOutsidelean\n  // };\n\n\n  const movePiece = (fromSquare, toSquare) => {\n    const movingContent = () => {\n      // here we will move the actual piece from one sqaure to another.\n      console.log(\"inside move\", fromSquare, toSquare); // 1. mapObj[toSquare] = mapObj[fromSquare] to the obj\n      // 2. delete the property whose key is \"fromSquare\" from mapObj\n      // const path = getTheFigurePath(fromSquare, toSquare);\n\n      if (check === true) {\n        return;\n      } // if (!checkPath(path)) return;\n\n\n      mapObj[toSquare] = mapObj[fromSquare];\n      delete mapObj[fromSquare];\n      setPlayer(!player);\n      console.log(\"player is: \", player);\n    };\n\n    if (player === true) {\n      if (mapObj[fromSquare].player === true) {\n        movingContent();\n      }\n    } else if (player === false) {\n      if (mapObj[fromSquare].player === false) {\n        movingContent();\n      }\n    }\n  }; // useEffect(() => {\n  //   console.log(\"inEffect\", fromSquare, toSquare);\n  //   if (fromSquare && toSquare) {\n  //     movePiece(fromSquare, toSquare);\n  //     // setToSquare();\n  //   }\n  // }, [fromSquare, toSquare]);\n\n\n  const parseToNumber = square => {\n    const [row, col] = square.split(\"\");\n    console.log(\"splitted\");\n    return [parseInt(row), parseInt(col)];\n  };\n\n  const addPossibleCellToPath = (nextPossibleRow, nextPossibleCol, nextPossibleMoves) => {\n    const nextPossibleCell = nextPossibleRow.toString() + nextPossibleCol.toString(); // remove the options of jumping above current player figures\n    // if (\n    //   mapObj[nextPossibleCell] &&\n    //   mapObj[nextPossibleCell].player === player\n    // ) {\n    //   return false;\n    // }\n    // add the last opponent cell, so i can remove him on play, and return to avoid the path to continue\n    // if (\n    //   mapObj[nextPossibleCell] &&\n    //   mapObj[nextPossibleCell].player !== player\n    // ) {\n    //   nextPossibleMoves[nextPossibleCell] = mapObj[nextPossibleCell];\n    //   return false;\n    // }\n\n    if (!mapObj[nextPossibleCell]) {\n      return nextPossibleMoves[nextPossibleCell] = \"empty\";\n    } else return nextPossibleMoves[nextPossibleCell] = mapObj[nextPossibleCell];\n  };\n\n  const findPath = fromSquare => {\n    let nextPossibleMoves = {};\n\n    if (!fromSquare) {\n      return {};\n    } else if (!mapObj[fromSquare]) {\n      return {};\n    }\n\n    const [moveFromRow, moveFromCol] = parseToNumber(fromSquare);\n    let squareToCheck = \"44\";\n\n    const insideMovingRook = (i, rookPath) => {\n      squareToCheck = i.toString() + moveFromCol;\n      console.log(typeof squareToCheck);\n      let squareInsideBoard = squareToCheck >= 0 || squareToCheck <= 77 ? true : false;\n      let isSquareEmpty = !mapObj[squareToCheck] ? true : false;\n      console.log(squareInsideBoard);\n      console.log(isSquareEmpty);\n\n      if (squareInsideBoard && isSquareEmpty) {\n        // if the next square is empty and inside boards then push the empty into rookPath\n        console.log(\"inside if\");\n        console.log(rookPath);\n        rookPath[squareToCheck] = \"empty\";\n      } else return rookPath;\n    };\n\n    const bishopFunctionInfo = i => {\n      addPossibleCellToPath(moveFromRow + i, moveFromCol + i, nextPossibleMoves);\n      addPossibleCellToPath(moveFromRow - i, moveFromCol - i, nextPossibleMoves);\n      addPossibleCellToPath(moveFromRow + i, moveFromCol - i, nextPossibleMoves);\n      addPossibleCellToPath(moveFromRow - i, moveFromCol + i, nextPossibleMoves);\n    };\n\n    const pawnFunctionInfo = () => {\n      addPossibleCellToPath(moveFromRow - 1, moveFromCol, nextPossibleMoves);\n      addPossibleCellToPath(moveFromRow + 1, moveFromCol, nextPossibleMoves);\n    };\n\n    if (mapObj[fromSquare].type === \"pawn\") {\n      const getNextPawnMove = () => {\n        if (mapObj[fromSquare].player === false) {\n          if (fromSquare[0] === \"1\") {\n            addPossibleCellToPath(moveFromRow + 2, moveFromCol, nextPossibleMoves);\n            addPossibleCellToPath(moveFromRow + 1, moveFromCol, nextPossibleMoves);\n            return nextPossibleMoves;\n          }\n        }\n\n        if (mapObj[fromSquare].player === true) {\n          if (fromSquare[0] === \"6\") {\n            addPossibleCellToPath(moveFromRow - 2, moveFromCol, nextPossibleMoves);\n            addPossibleCellToPath(moveFromRow - 1, moveFromCol, nextPossibleMoves);\n            return nextPossibleMoves;\n          }\n        }\n\n        pawnFunctionInfo();\n        return nextPossibleMoves;\n      };\n\n      const result = getNextPawnMove(fromSquare);\n      console.log(\"kkk\", result);\n      return result;\n    } // console.log(fromSquare, mapObj);\n    // if (mapObj[fromSquare].type === \"knight\") {\n    //   const getNextKnightMove = () => {\n    //     //[[moveFromRow,moveFromCol],[moveFromCol,moveFromRow]]].\n    //     // [\n    //     //   [1, 2],\n    //     //   [-1, 2],\n    //     //   [1, -2],\n    //     //   [-1, -2],\n    //     // ].reduce((acc, [f1, f2]) => {\n    //     //   return [\n    //     //     ...acc,\n    //     //     [moveFromRow + f1, moveFromCol + f2],\n    //     //     [moveFromCol + f1, moveFromRow + f2],\n    //     //   ];\n    //     // }, []);\n    //     addPossibleCellToPath(\n    //       moveFromRow - 2,\n    //       moveFromCol + 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow - 2,\n    //       moveFromCol - 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow + 2,\n    //       moveFromCol + 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow + 2,\n    //       moveFromCol - 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow - 1,\n    //       moveFromCol + 2,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow - 1,\n    //       moveFromCol - 2,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow + 1,\n    //       moveFromCol + 2,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow + 1,\n    //       moveFromCol - 2,\n    //       nextPossibleMoves\n    //     );\n    //     return nextPossibleMoves;\n    //   };\n    //   const result = getNextKnightMove(fromSquare);\n    //   console.log(\"kkk\", result);\n    //   return result;\n    // }\n\n\n    if (mapObj[fromSquare].type === \"rook\") {\n      console.log(\"rooked\");\n\n      const getNextRookMove = () => {\n        let newRookPath = {};\n        let rookPathInAllDirections = {};\n        let rookPath = {};\n        let squareAbove = parseInt(fromSquare[0]) - 1;\n        let squareDownwards = parseInt(fromSquare[0]) + 1;\n        let squareLeftwards = parseInt(fromSquare[1]) - 1;\n        let squareRightwards = parseInt(fromSquare[1]) + 1;\n\n        for (let i = squareAbove; i >= 0; i--) {\n          // go UPwards and check if the square is not empty or not the end of the board;\n          console.log(fromSquare);\n          console.log(i.toString() + moveFromCol);\n\n          if (!mapObj[i.toString() + moveFromCol]) {\n            insideMovingRook(i, rookPath);\n          } else ;\n        }\n\n        console.log(\"still here\");\n\n        for (let i = squareDownwards; i >= 0; i++) {\n          console.log(\"going down 1\"); // go DOWNwards and check if the square is not empty or not the end of the board;\n\n          if (!mapObj[i.toString() + moveFromCol]) {\n            console.log(\"going down 2\");\n            insideMovingRook(i, rookPath);\n          } else return rookPath;\n        } // for (let i = squareLeftwards; i >= 0; i--) {\n        //   // go Leftwards and check if the square is not empty or not the end of the board;\n        //   if (!mapObj[i.toString() + fromSquare[1]]) {\n        //     insideMovingRook(i, rookPath);\n        //   } else return rookPath;\n        // }\n        // for (let i = squareRightwards; i >= 0; i++) {\n        //   // go Rightwards and check if the square is not empty or not the end of the board;\n        //   if (!mapObj[i.toString() + fromSquare[1]]) {\n        //     insideMovingRook(i, rookPath);\n        //   } else return rookPath;\n        // }\n\n\n        return rookPath;\n      };\n\n      const result = getNextRookMove(fromSquare);\n      console.log(\"kkk\", result);\n      return result;\n    } // if (mapObj[fromSquare].type === \"bishop\") {\n    //   const getNextBishopMove = () => {\n    //     for (let i = fromSquare[0]; i <= 7; i++) {\n    //       bishopFunctionInfo(i);\n    //     }\n    //     for (let i = fromSquare[0]; i >= 0; i--) {\n    //       bishopFunctionInfo(i);\n    //     }\n    //     return nextPossibleMoves;\n    //   };\n    //   const result = getNextBishopMove(fromSquare);\n    //   console.log(\"kkk\", result);\n    //   return result;\n    // }\n    // if (mapObj[fromSquare].type === \"queen\") {\n    //   const getNextQueenMove = () => {\n    //     for (let i = 1; i <= 7; i++) {\n    //       bishopFunctionInfo(i);\n    //       rookFunctionInfo(i);\n    //     }\n    //     return nextPossibleMoves;\n    //   };\n    //   const result = getNextQueenMove(fromSquare);\n    //   console.log(\"kkk\", result);\n    //   return result;\n    // }\n    // if (mapObj[fromSquare].type === \"king\") {\n    //   const getNextKingMove = () => {\n    //     pawnFunctionInfo();\n    //     addPossibleCellToPath(\n    //       moveFromRow + 1,\n    //       moveFromCol - 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow + 1,\n    //       moveFromCol + 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(moveFromRow, moveFromCol - 1, nextPossibleMoves);\n    //     addPossibleCellToPath(moveFromRow, moveFromCol + 1, nextPossibleMoves);\n    //     addPossibleCellToPath(\n    //       moveFromRow - 1,\n    //       moveFromCol - 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow - 1,\n    //       moveFromCol + 1,\n    //       nextPossibleMoves\n    //     );\n    //     return nextPossibleMoves;\n    //   };\n    //   const result = getNextKingMove(fromSquare);\n    //   console.log(\"kkk\", result);\n    //   return result;\n    // }\n\n  };\n\n  const handleClick = con => {\n    console.log(player);\n\n    if (count === 0) {\n      if (!mapObj[con]) {\n        //first spuare to click cant be empty\n        return;\n      }\n    }\n\n    if (count === 0) {\n      setFromSquare(con);\n      setCount(count + 1);\n      console.log(\"this con mada\", con);\n      setChosen(con);\n      console.log(\"chosen:\", chosen);\n      return;\n    } //second click\n    // fromSquare -> toSqaure\n\n\n    if (!mapObj[con] || mapObj[fromSquare].player !== mapObj[con].player) {\n      const moveFigureAlready = (fromSquare, con) => {\n        if (findPath(fromSquare)[con]) {\n          console.log(findPath(fromSquare)[con]); //check if the second click is in path\n\n          const returnPathArr = Object.values(findPath(fromSquare));\n\n          for (let i = 0; i <= returnPathArr.length; i++) {\n            console.log(\"im fromsquare:\", fromSquare);\n            console.log(\"im the fucking return array:\", returnPathArr); //scan through path and not let passing through NON-EMPTY\n\n            if (returnPathArr[i] === \"empty\") {\n              console.log(\"i survived\");\n              moveInvoke(fromSquare, con);\n              setCount(0);\n              return;\n            }\n\n            return;\n          }\n        }\n      };\n\n      moveFigureAlready(fromSquare, con);\n    }\n\n    setCount(0);\n  };\n\n  console.log(chosen);\n  const path = findPath(chosen);\n  console.log(path);\n  return (\n    /*#__PURE__*/\n    // we will map 8 * 8 of arrays to build our board.\n    React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 735,\n        columnNumber: 5\n      }\n    }, Array(8).fill(0).map((e, rowIndex) => {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        style: {\n          display: \"flex\",\n          flexDirection: \"row\"\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 740,\n          columnNumber: 13\n        }\n      }, Array(8).fill(0).map((e, squareIndex) => {\n        const colorPic = (squareIndex + rowIndex) % 2 === 0 ? true : false; // we will caculate the spread of black & white color on the board and identify each square\n\n        const numRow = rowIndex.toString();\n        const numSquare = squareIndex.toString();\n        const con = numRow.concat(numSquare);\n        const piece = mapObj[con];\n        const isHighlighted = path[con] ? true : false;\n        console.log(isHighlighted);\n        return (\n          /*#__PURE__*/\n          //props\n          React.createElement(Square, {\n            isHighlighted: isHighlighted,\n            color: colorPic,\n            piece: piece,\n            onClick: () => handleClick(con) // onMouseOver={() => handleMouseOver(colorPic)}\n            ,\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 760,\n              columnNumber: 21\n            }\n          })\n        );\n      }));\n    }), /*#__PURE__*/React.createElement(\"h1\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 773,\n        columnNumber: 7\n      }\n    }, printCheckOutside), /*#__PURE__*/React.createElement(\"h1\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 774,\n        columnNumber: 7\n      }\n    }, printPlayerOutside))\n  );\n};\n\nfunction App() {\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 781,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(Board, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 782,\n      columnNumber: 7\n    }\n  }));\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/mac/Chess/src/App.js"],"names":["React","useState","useEffect","Square","mapObj","type","player","Board","count","setCount","fromSquare","setFromSquare","setPlayer","check","setCheck","chosen","setChosen","console","log","printCheckOutside","printPlayerOutside","printCheck","printPlayer","moveInvoke","moveFrom","moveTo","movePiece","findKing","startingSquare","entries","Object","i","length","kingIndex","toSquare","movingContent","parseToNumber","square","row","col","split","parseInt","addPossibleCellToPath","nextPossibleRow","nextPossibleCol","nextPossibleMoves","nextPossibleCell","toString","findPath","moveFromRow","moveFromCol","squareToCheck","insideMovingRook","rookPath","squareInsideBoard","isSquareEmpty","bishopFunctionInfo","pawnFunctionInfo","getNextPawnMove","result","getNextRookMove","newRookPath","rookPathInAllDirections","squareAbove","squareDownwards","squareLeftwards","squareRightwards","handleClick","con","moveFigureAlready","returnPathArr","values","path","Array","fill","map","e","rowIndex","display","flexDirection","squareIndex","colorPic","numRow","numSquare","concat","piece","isHighlighted","App"],"mappings":"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IAAI2B,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIF,OAAO,CAACG,MAAR,GAAiB,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,UAAIE,SAAJ;;AACA,UAAIJ,OAAO,CAACE,CAAD,CAAP,CAAW,CAAX,EAAc1B,IAAd,KAAuB,MAA3B,EAAmC;AACjC,YAAIwB,OAAO,CAACE,CAAD,CAAP,CAAW,CAAX,EAAczB,MAAd,KAAyBF,MAAM,CAACwB,cAAD,CAAN,CAAuBtB,MAApD,EAA4D;AAC1D2B,UAAAA,SAAS,GAAGJ,OAAO,CAACE,CAAD,CAAP,CAAW,CAAX,CAAZ;AACAd,UAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ,EAA+Be,SAA/B;AACA,iBAAOA,SAAP;AACD;AACF;AACF;AACF,GAdD,CApCkB,CAoDlB;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAEA,QAAMP,SAAS,GAAG,CAAChB,UAAD,EAAawB,QAAb,KAA0B;AAC1C,UAAMC,aAAa,GAAG,MAAM;AAC1B;AACAlB,MAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2BR,UAA3B,EAAuCwB,QAAvC,EAF0B,CAG1B;AACA;AACA;;AACA,UAAIrB,KAAK,KAAK,IAAd,EAAoB;AAClB;AACD,OARyB,CAS1B;;;AACAT,MAAAA,MAAM,CAAC8B,QAAD,CAAN,GAAmB9B,MAAM,CAACM,UAAD,CAAzB;AACA,aAAON,MAAM,CAACM,UAAD,CAAb;AACAE,MAAAA,SAAS,CAAC,CAACN,MAAF,CAAT;AACAW,MAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2BZ,MAA3B;AACD,KAdD;;AAeA,QAAIA,MAAM,KAAK,IAAf,EAAqB;AACnB,UAAIF,MAAM,CAACM,UAAD,CAAN,CAAmBJ,MAAnB,KAA8B,IAAlC,EAAwC;AACtC6B,QAAAA,aAAa;AACd;AACF,KAJD,MAIO,IAAI7B,MAAM,KAAK,KAAf,EAAsB;AAC3B,UAAIF,MAAM,CAACM,UAAD,CAAN,CAAmBJ,MAAnB,KAA8B,KAAlC,EAAyC;AACvC6B,QAAAA,aAAa;AACd;AACF;AACF,GAzBD,CArSkB,CA+TlB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,QAAMC,aAAa,GAAIC,MAAD,IAAY;AAChC,UAAM,CAAC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","sourcesContent":["import React, { useState, useEffect } from \"react\";\n// import logo from \"./logo.svg\";\nimport \"./App.css\";\nimport Square from \"./Square\";\n// import styled from \"styled-components\";\n\n// fromSquare \"10\"\n// toSquare \"21\"\n// mapObj\n// 2. mapObj[toSquare] = mapObj[fromSquare] to the obj\n// 1. delete the property whose key is \"fromSquare\" from mapObj\n\n// const Div = styled.div({\n//   background: \"yellow\",\n//   opacity: \"1\",\n//   \":hover\": {\n//     background: \"red\",\n\n//   },\n// });\nconst mapObj = {\n  //database of the board\n  \"00\": { type: \"rook\", player: false },\n  \"01\": { type: \"knight\", player: false },\n  \"02\": { type: \"bishop\", player: false },\n  \"03\": { type: \"king\", player: false },\n  \"04\": { type: \"queen\", player: false },\n  \"05\": { type: \"bishop\", player: false },\n  \"06\": { type: \"knight\", player: false },\n  \"07\": { type: \"rook\", player: false },\n  \"10\": { type: \"pawn\", player: false },\n  \"11\": { type: \"pawn\", player: false },\n  \"12\": { type: \"pawn\", player: false },\n  \"13\": { type: \"pawn\", player: false },\n  \"14\": { type: \"pawn\", player: false },\n  \"15\": { type: \"pawn\", player: false },\n  \"16\": { type: \"pawn\", player: false },\n  \"17\": { type: \"pawn\", player: false },\n  \"60\": { type: \"pawn\", player: true },\n  \"61\": { type: \"pawn\", player: true },\n  \"62\": { type: \"pawn\", player: true },\n  \"63\": { type: \"pawn\", player: true },\n  \"64\": { type: \"pawn\", player: true },\n  \"65\": { type: \"pawn\", player: true },\n  \"66\": { type: \"pawn\", player: true },\n  \"67\": { type: \"pawn\", player: true },\n  \"70\": { type: \"rook\", player: true },\n  \"71\": { type: \"knight\", player: true },\n  \"72\": { type: \"bishop\", player: true },\n  \"73\": { type: \"king\", player: true },\n  \"74\": { type: \"queen\", player: true },\n  \"75\": { type: \"bishop\", player: true },\n  \"76\": { type: \"knight\", player: true },\n  \"77\": { type: \"rook\", player: true },\n};\n\nconst Board = () => {\n  const [count, setCount] = useState(0);\n  const [fromSquare, setFromSquare] = useState();\n  const [player, setPlayer] = useState(true);\n  const [check, setCheck] = useState(false);\n  const [chosen, setChosen] = useState();\n  // const [toSquare, setToSquare] = useState();\n  // useEffect(() => {\n  //   if (check === true) {\n  //     console.log(\"check is true\");\n  //     setCount(0);\n  //   }\n  // }, 1);\n  console.log(chosen);\n\n  let printCheckOutside;\n  let printPlayerOutside;\n  const printCheck = (check) => {\n    check === false\n      ? (printCheckOutside = \"no check at this point\")\n      : (printCheckOutside = \"check, please protect your King\");\n  };\n  const printPlayer = (player) => {\n    player === true\n      ? (printPlayerOutside = \"white player's turn\")\n      : (printPlayerOutside = \"blue player's turn\");\n  };\n  printCheck(check);\n  printPlayer(player);\n  const moveInvoke = (moveFrom, moveTo) => {\n    // the actual movePiece\n    movePiece(moveFrom, moveTo);\n  };\n\n  check === false ? console.log(\"check false\") : console.log(\"check truth\");\n  // checking if theres a check in play\n  const findKing = (startingSquare) => {\n    // here we find the king's key (location)\n    const entries = Object.entries(mapObj);\n    // console.log(entries);\n    for (let i = 0; i <= entries.length - 1; i++) {\n      let kingIndex;\n      if (entries[i][1].type === \"king\") {\n        if (entries[i][1].player !== mapObj[startingSquare].player) {\n          kingIndex = entries[i][0];\n          console.log(\"insideFindKing:\", kingIndex);\n          return kingIndex;\n        }\n      }\n    }\n  };\n\n  // useState chosen\n  // caculate which cells i chose and which will be on my path\n  // scan through the cells and paint the chosen\n\n  // const getTheFigurePath = (moveFrom, moveTo) => {\n  //   const path = [];\n  //   let passingSquare;\n  //   const [moveFromRow, moveFromCol] = splitAndParseToNumber(moveFrom);\n  //   const [moveToRow, moveToCol] = splitAndParseToNumber(moveTo);\n  //   let j = moveFromCol;\n  //   //fill the path with the squares we past\n  //   //check witch is bigger , the rows move from or rows move to . if moveTo rows? then we going down, else going up\n  //   //check the going up movements:TODO - SET IN A OTHER FUNCTION ?\n  //   if (moveFromRow > moveToRow) {\n  //     //going only up the board\n  //     if (moveFromCol === moveToCol) {\n  //       for (let i = moveFromRow; i >= moveToRow; i--) {\n  //         passingSquare = i.toString() + moveFromCol.toString();\n  //         path.push(passingSquare);\n  //       }\n  //     }\n  //     //going up and move left\n  //     else if (moveFromCol > moveToCol) {\n  //       for (let i = moveFromRow; i > moveToRow; i--) {\n  //         passingSquare = i.toString() + j.toString();\n  //         path.push(passingSquare);\n  //         if (j >= moveToCol) j--;\n  //       }\n  //       path.push(moveTo);\n  //     }\n  //     //move up and turn right\n  //     else if (moveFromCol < moveToCol) {\n  //       for (let i = moveFromRow; i >= moveToRow; i--) {\n  //         passingSquare = i.toString() + j.toString();\n  //         path.push(passingSquare);\n  //         if (j <= moveToCol) j++;\n  //       }\n  //       path.push(moveTo);\n  //     }\n  //   }\n  //   // Check for the going down movements:\n  //   else {\n  //     //only goes down:\n  //     if (moveFromCol === moveToCol) {\n  //       for (let i = moveFromRow; i <= moveToRow; i++) {\n  //         passingSquare = i.toString() + moveToCol.toString();\n  //         path.push(passingSquare);\n  //       }\n  //       //goes down and right\n  //     } else if (moveFromCol < moveToCol) {\n  //       for (let i = moveFromRow; i <= moveToRow; i++) {\n  //         passingSquare = i.toString() + j.toString();\n  //         path.push(passingSquare);\n  //         if (j <= moveToCol) j++;\n  //       }\n  //       //goes down and left\n  //     } else {\n  //       for (let i = moveFromRow; i <= moveToRow; i++) {\n  //         passingSquare = i.toString() + j.toString();\n  //         if (j >= moveToCol) j--;\n  //       }\n  //     }\n  //   }\n  //   return path;\n  // };\n\n  // const movePawn = (fromMove, toMove) => {\n  //   // console.log(mapObj[fromSquare].player);\n  //   if (mapObj[fromSquare].player === false) {\n  //     // if the pawn is black or white he can go to certain direction and eat a certain way\n  //     //only the pawns first step may be two steps\n  //     if (fromMove[0] - toMove[0] === -2) {\n  //       //only if its the pawn first move it can go two steps\n  //       if (fromMove[0] === \"1\") {\n  //         return moveInvoke(fromSquare, toMove);\n  //       }\n  //     }\n  //     if (fromMove[0] - toMove[0] === -1) {\n  //       //normally a pawn can only go straight\n  //       if (fromMove[1] - toMove[1] === 0) {\n  //         if (!mapObj[toMove]) {\n  //           return moveInvoke(fromSquare, toMove);\n  //         }\n  //       } else if (\n  //         fromMove[1] - toMove[1] === 1 ||\n  //         fromMove[1] - toMove[1] === -1\n  //       ) {\n  //         // in case of eating\n  //         if (!mapObj[toMove]) {\n  //           return;\n  //         } else if (mapObj[fromSquare] !== mapObj[toMove]) {\n  //           return moveInvoke(fromSquare, toMove);\n  //         }\n  //       }\n  //     }\n  //   }\n  //   if (mapObj[fromSquare].player === true) {\n  //     if (fromMove[0] - toMove[0] === 2) {\n  //       //only if its the pawn first move it can go two steps\n  //       if (fromMove[0] === \"6\") {\n  //         return moveInvoke(fromSquare, toMove);\n  //       }\n  //     }\n  //     //case of white pawn go straight\n  //     if (fromMove[0] - toMove[0] === 1) {\n  //       if (fromMove[1] - toMove[1] === 0) {\n  //         if (!mapObj[toMove]) {\n  //           return moveInvoke(fromSquare, toMove);\n  //         }\n  //       } else if (\n  //         fromMove[1] - toMove[1] === 1 ||\n  //         fromMove[1] - toMove[1] === -1\n  //       ) {\n  //         //in case of eating\n  //         if (!mapObj[toMove]) {\n  //           return;\n  //         } else if (mapObj[fromSquare] !== mapObj[toMove]) {\n  //           return moveInvoke(fromSquare, toMove);\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return console.log(\"nah\");\n  // };\n  // const moveRook = (fromMove, con) => {\n  //   // rook can only move straight up\\down or straight left\\right\n  //   const fromToZeroIndex = fromMove[0] - con[0];\n  //   const fromToOneIndex = fromMove[1] - con[1];\n\n  //   if (fromToZeroIndex <= 7 || fromToZeroIndex >= -7) {\n  //     if (fromToOneIndex === 0) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  //   if (fromMove[0] - con[0] === 0) {\n  //     if (fromToOneIndex <= 7 || fromToOneIndex >= -7) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  // };\n  // const moveKnight = (fromMove, con) => {\n  //   // knight logic. if it moves 1 further, it means 2 to the side, if 2 further, 1 to the side.\n\n  //   const fromToZeroIndex = fromMove[0] - con[0];\n  //   const fromToOneIndex = fromMove[1] - con[1];\n  //   if (fromToZeroIndex === 1 || fromToZeroIndex === -1) {\n  //     if (fromToOneIndex === -2 || fromToOneIndex === 2) {\n  //       return moveInvoke(fromMove, con);\n  //     }\n  //   } else if (fromToZeroIndex === 2 || fromToZeroIndex === -2) {\n  //     if (fromToOneIndex === 1 || fromToOneIndex === -1) {\n  //       return moveInvoke(fromMove, con);\n  //     }\n  //   }\n  // };\n\n  // const moveBishop = (fromMove, con) => {\n  //   // bishop can only move at an angle on its same color.\n  //   const fromToZeroIndex = fromMove[0] - con[0];\n  //   const fromToOneIndex = fromMove[1] - con[1];\n  //   let i = fromToZeroIndex;\n  //   if (fromToZeroIndex === i || fromToZeroIndex === -i) {\n  //     if (fromToOneIndex === i || fromToOneIndex === -i) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  // };\n  // const moveQueen = (fromMove, con) => {\n  //   // can behave as any other piece apart from knight.\n  //   const fromToZeroIndex = fromMove[0] - con[0];\n  //   const fromToOneIndex = fromMove[1] - con[1];\n  //   let i = fromToZeroIndex;\n  //   if (\n  //     fromToZeroIndex === i ||\n  //     fromToZeroIndex === -i ||\n  //     fromToZeroIndex === 0\n  //   ) {\n  //     if (\n  //       fromToOneIndex === i ||\n  //       fromToOneIndex === -i ||\n  //       fromToOneIndex === 0\n  //     ) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  //   if (fromMove[0] - con[0] === 0) {\n  //     if (fromToOneIndex <= 7 || fromToOneIndex >= -7) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  //   return console.log(\"nah\");\n  // };\n  // const moveKing = (fromMove, con) => {\n  //   const fromToZeroIndex = fromMove[0] - con[0];\n  //   const fromToOneIndex = fromMove[1] - con[1];\n\n  //   if (\n  //     fromToZeroIndex === 1 ||\n  //     fromToZeroIndex === 0 ||\n  //     fromToZeroIndex === -1\n  //   ) {\n  //     if (\n  //       fromToOneIndex === 1 ||\n  //       fromToOneIndex === 0 ||\n  //       fromToOneIndex === -1\n  //     ) {\n  //       return moveInvoke(fromSquare, con);\n  //     }\n  //   }\n  //   return console.log(\"nah\");\n  // };\n\n  // const checkPath = (path) => {\n  //   //get an path array\n  //   for (let i = 1; i <= path.length; i++) {\n  //     let figure = path[i];\n  //     if (mapObj[figure]) {\n  //       // console.log(\"figured\");\n  //       // console.log(mapObj[path[0]].type);\n  //       if (mapObj[path[0]].type == \"knight\") {\n  //         return true;\n  //       }\n  //     }\n  //     if (mapObj[figure]) return false;\n  //     if (i === path.length - 1) {\n  //       if (mapObj[figure]) {\n  //         if (mapObj[figure].player !== mapObj[figure].player) {\n  //           return false;\n  //         }\n  //       }\n  //     }\n  //     //if last cell is empty ?\n  //     // if the last cell is the same color as the current player\n  //     //if the last cell is the other color\n\n  //     //last cell.\n  //   }\n  //   return true;\n  //   // return printCheckOutsidelean\n  // };\n\n  const movePiece = (fromSquare, toSquare) => {\n    const movingContent = () => {\n      // here we will move the actual piece from one sqaure to another.\n      console.log(\"inside move\", fromSquare, toSquare);\n      // 1. mapObj[toSquare] = mapObj[fromSquare] to the obj\n      // 2. delete the property whose key is \"fromSquare\" from mapObj\n      // const path = getTheFigurePath(fromSquare, toSquare);\n      if (check === true) {\n        return;\n      }\n      // if (!checkPath(path)) return;\n      mapObj[toSquare] = mapObj[fromSquare];\n      delete mapObj[fromSquare];\n      setPlayer(!player);\n      console.log(\"player is: \", player);\n    };\n    if (player === true) {\n      if (mapObj[fromSquare].player === true) {\n        movingContent();\n      }\n    } else if (player === false) {\n      if (mapObj[fromSquare].player === false) {\n        movingContent();\n      }\n    }\n  };\n  // useEffect(() => {\n  //   console.log(\"inEffect\", fromSquare, toSquare);\n  //   if (fromSquare && toSquare) {\n  //     movePiece(fromSquare, toSquare);\n  //     // setToSquare();\n  //   }\n  // }, [fromSquare, toSquare]);\n\n  const parseToNumber = (square) => {\n    const [row, col] = square.split(\"\");\n    console.log(\"splitted\");\n    return [parseInt(row), parseInt(col)];\n  };\n\n  const addPossibleCellToPath = (\n    nextPossibleRow,\n    nextPossibleCol,\n    nextPossibleMoves\n  ) => {\n    const nextPossibleCell =\n      nextPossibleRow.toString() + nextPossibleCol.toString();\n    // remove the options of jumping above current player figures\n    // if (\n    //   mapObj[nextPossibleCell] &&\n    //   mapObj[nextPossibleCell].player === player\n    // ) {\n    //   return false;\n    // }\n    // add the last opponent cell, so i can remove him on play, and return to avoid the path to continue\n\n    // if (\n    //   mapObj[nextPossibleCell] &&\n    //   mapObj[nextPossibleCell].player !== player\n    // ) {\n    //   nextPossibleMoves[nextPossibleCell] = mapObj[nextPossibleCell];\n    //   return false;\n    // }\n    if (!mapObj[nextPossibleCell]) {\n      return (nextPossibleMoves[nextPossibleCell] = \"empty\");\n    } else\n      return (nextPossibleMoves[nextPossibleCell] = mapObj[nextPossibleCell]);\n  };\n\n  const findPath = (fromSquare) => {\n    let nextPossibleMoves = {};\n    if (!fromSquare) {\n      return {};\n    } else if (!mapObj[fromSquare]) {\n      return {};\n    }\n    const [moveFromRow, moveFromCol] = parseToNumber(fromSquare);\n    let squareToCheck = \"44\";\n    const insideMovingRook = (i, rookPath) => {\n      squareToCheck = i.toString() + moveFromCol;\n      console.log(typeof squareToCheck);\n      let squareInsideBoard =\n        squareToCheck >= 0 || squareToCheck <= 77 ? true : false;\n      let isSquareEmpty = !mapObj[squareToCheck] ? true : false;\n      console.log(squareInsideBoard);\n      console.log(isSquareEmpty);\n      if (squareInsideBoard && isSquareEmpty) {\n        // if the next square is empty and inside boards then push the empty into rookPath\n        console.log(\"inside if\");\n        console.log(rookPath);\n        rookPath[squareToCheck] = \"empty\";\n      } else return rookPath;\n    };\n\n    const bishopFunctionInfo = (i) => {\n      addPossibleCellToPath(\n        moveFromRow + i,\n        moveFromCol + i,\n        nextPossibleMoves\n      );\n      addPossibleCellToPath(\n        moveFromRow - i,\n        moveFromCol - i,\n        nextPossibleMoves\n      );\n      addPossibleCellToPath(\n        moveFromRow + i,\n        moveFromCol - i,\n        nextPossibleMoves\n      );\n      addPossibleCellToPath(\n        moveFromRow - i,\n        moveFromCol + i,\n        nextPossibleMoves\n      );\n    };\n    const pawnFunctionInfo = () => {\n      addPossibleCellToPath(moveFromRow - 1, moveFromCol, nextPossibleMoves);\n      addPossibleCellToPath(moveFromRow + 1, moveFromCol, nextPossibleMoves);\n    };\n    if (mapObj[fromSquare].type === \"pawn\") {\n      const getNextPawnMove = () => {\n        if (mapObj[fromSquare].player === false) {\n          if (fromSquare[0] === \"1\") {\n            addPossibleCellToPath(\n              moveFromRow + 2,\n              moveFromCol,\n              nextPossibleMoves\n            );\n            addPossibleCellToPath(\n              moveFromRow + 1,\n              moveFromCol,\n              nextPossibleMoves\n            );\n            return nextPossibleMoves;\n          }\n        }\n        if (mapObj[fromSquare].player === true) {\n          if (fromSquare[0] === \"6\") {\n            addPossibleCellToPath(\n              moveFromRow - 2,\n              moveFromCol,\n              nextPossibleMoves\n            );\n            addPossibleCellToPath(\n              moveFromRow - 1,\n              moveFromCol,\n              nextPossibleMoves\n            );\n            return nextPossibleMoves;\n          }\n        }\n        pawnFunctionInfo();\n        return nextPossibleMoves;\n      };\n      const result = getNextPawnMove(fromSquare);\n\n      console.log(\"kkk\", result);\n      return result;\n    }\n    // console.log(fromSquare, mapObj);\n    // if (mapObj[fromSquare].type === \"knight\") {\n    //   const getNextKnightMove = () => {\n    //     //[[moveFromRow,moveFromCol],[moveFromCol,moveFromRow]]].\n    //     // [\n    //     //   [1, 2],\n    //     //   [-1, 2],\n    //     //   [1, -2],\n    //     //   [-1, -2],\n    //     // ].reduce((acc, [f1, f2]) => {\n    //     //   return [\n    //     //     ...acc,\n    //     //     [moveFromRow + f1, moveFromCol + f2],\n    //     //     [moveFromCol + f1, moveFromRow + f2],\n    //     //   ];\n    //     // }, []);\n\n    //     addPossibleCellToPath(\n    //       moveFromRow - 2,\n    //       moveFromCol + 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow - 2,\n    //       moveFromCol - 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow + 2,\n    //       moveFromCol + 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow + 2,\n    //       moveFromCol - 1,\n    //       nextPossibleMoves\n    //     );\n\n    //     addPossibleCellToPath(\n    //       moveFromRow - 1,\n    //       moveFromCol + 2,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow - 1,\n    //       moveFromCol - 2,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow + 1,\n    //       moveFromCol + 2,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow + 1,\n    //       moveFromCol - 2,\n    //       nextPossibleMoves\n    //     );\n    //     return nextPossibleMoves;\n    //   };\n    //   const result = getNextKnightMove(fromSquare);\n\n    //   console.log(\"kkk\", result);\n    //   return result;\n    // }\n    if (mapObj[fromSquare].type === \"rook\") {\n      console.log(\"rooked\");\n      const getNextRookMove = () => {\n        let newRookPath = {};\n        let rookPathInAllDirections = {};\n        let rookPath = {};\n        let squareAbove = parseInt(fromSquare[0]) - 1;\n        let squareDownwards = parseInt(fromSquare[0]) + 1;\n        let squareLeftwards = parseInt(fromSquare[1]) - 1;\n        let squareRightwards = parseInt(fromSquare[1]) + 1;\n\n        for (let i = squareAbove; i >= 0; i--) {\n          // go UPwards and check if the square is not empty or not the end of the board;\n          console.log(fromSquare);\n          console.log(i.toString() + moveFromCol);\n          if (!mapObj[i.toString() + moveFromCol]) {\n            insideMovingRook(i, rookPath);\n          } else;\n        }\n\n        console.log(\"still here\");\n\n        for (let i = squareDownwards; i >= 0; i++) {\n          console.log(\"going down 1\");\n          // go DOWNwards and check if the square is not empty or not the end of the board;\n          if (!mapObj[i.toString() + moveFromCol]) {\n            console.log(\"going down 2\");\n            insideMovingRook(i, rookPath);\n          } else return rookPath;\n        }\n\n        // for (let i = squareLeftwards; i >= 0; i--) {\n        //   // go Leftwards and check if the square is not empty or not the end of the board;\n        //   if (!mapObj[i.toString() + fromSquare[1]]) {\n        //     insideMovingRook(i, rookPath);\n        //   } else return rookPath;\n        // }\n        // for (let i = squareRightwards; i >= 0; i++) {\n        //   // go Rightwards and check if the square is not empty or not the end of the board;\n        //   if (!mapObj[i.toString() + fromSquare[1]]) {\n        //     insideMovingRook(i, rookPath);\n        //   } else return rookPath;\n        // }\n\n        return rookPath;\n      };\n      const result = getNextRookMove(fromSquare);\n      console.log(\"kkk\", result);\n      return result;\n    }\n    // if (mapObj[fromSquare].type === \"bishop\") {\n    //   const getNextBishopMove = () => {\n    //     for (let i = fromSquare[0]; i <= 7; i++) {\n    //       bishopFunctionInfo(i);\n    //     }\n    //     for (let i = fromSquare[0]; i >= 0; i--) {\n    //       bishopFunctionInfo(i);\n    //     }\n    //     return nextPossibleMoves;\n    //   };\n    //   const result = getNextBishopMove(fromSquare);\n\n    //   console.log(\"kkk\", result);\n    //   return result;\n    // }\n    // if (mapObj[fromSquare].type === \"queen\") {\n    //   const getNextQueenMove = () => {\n    //     for (let i = 1; i <= 7; i++) {\n    //       bishopFunctionInfo(i);\n    //       rookFunctionInfo(i);\n    //     }\n    //     return nextPossibleMoves;\n    //   };\n    //   const result = getNextQueenMove(fromSquare);\n\n    //   console.log(\"kkk\", result);\n    //   return result;\n    // }\n    // if (mapObj[fromSquare].type === \"king\") {\n    //   const getNextKingMove = () => {\n    //     pawnFunctionInfo();\n    //     addPossibleCellToPath(\n    //       moveFromRow + 1,\n    //       moveFromCol - 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow + 1,\n    //       moveFromCol + 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(moveFromRow, moveFromCol - 1, nextPossibleMoves);\n    //     addPossibleCellToPath(moveFromRow, moveFromCol + 1, nextPossibleMoves);\n    //     addPossibleCellToPath(\n    //       moveFromRow - 1,\n    //       moveFromCol - 1,\n    //       nextPossibleMoves\n    //     );\n    //     addPossibleCellToPath(\n    //       moveFromRow - 1,\n    //       moveFromCol + 1,\n    //       nextPossibleMoves\n    //     );\n    //     return nextPossibleMoves;\n    //   };\n    //   const result = getNextKingMove(fromSquare);\n\n    //   console.log(\"kkk\", result);\n    //   return result;\n    // }\n  };\n  const handleClick = (con) => {\n    console.log(player);\n    if (count === 0) {\n      if (!mapObj[con]) {\n        //first spuare to click cant be empty\n        return;\n      }\n    }\n    if (count === 0) {\n      setFromSquare(con);\n      setCount(count + 1);\n      console.log(\"this con mada\", con);\n      setChosen(con);\n      console.log(\"chosen:\", chosen);\n      return;\n    }\n    //second click\n    // fromSquare -> toSqaure\n    if (!mapObj[con] || mapObj[fromSquare].player !== mapObj[con].player) {\n      const moveFigureAlready = (fromSquare, con) => {\n        if (findPath(fromSquare)[con]) {\n          console.log(findPath(fromSquare)[con]);\n          //check if the second click is in path\n          const returnPathArr = Object.values(findPath(fromSquare));\n          for (let i = 0; i <= returnPathArr.length; i++) {\n            console.log(\"im fromsquare:\", fromSquare);\n            console.log(\"im the fucking return array:\", returnPathArr);\n            //scan through path and not let passing through NON-EMPTY\n            if (returnPathArr[i] === \"empty\") {\n              console.log(\"i survived\");\n              moveInvoke(fromSquare, con);\n              setCount(0);\n              return;\n            }\n            return;\n          }\n        }\n      };\n      moveFigureAlready(fromSquare, con);\n    }\n    setCount(0);\n  };\n\n  console.log(chosen);\n  const path = findPath(chosen);\n  console.log(path);\n\n  return (\n    // we will map 8 * 8 of arrays to build our board.\n    <div>\n      {Array(8)\n        .fill(0)\n        .map((e, rowIndex) => {\n          return (\n            <div\n              style={{\n                display: \"flex\",\n                flexDirection: \"row\",\n              }}\n            >\n              {Array(8)\n                .fill(0)\n                .map((e, squareIndex) => {\n                  const colorPic =\n                    (squareIndex + rowIndex) % 2 === 0 ? true : false;\n                  // we will caculate the spread of black & white color on the board and identify each square\n                  const numRow = rowIndex.toString();\n                  const numSquare = squareIndex.toString();\n                  const con = numRow.concat(numSquare);\n                  const piece = mapObj[con];\n                  const isHighlighted = path[con] ? true : false;\n                  console.log(isHighlighted);\n                  return (\n                    //props\n                    <Square\n                      isHighlighted={isHighlighted}\n                      color={colorPic}\n                      piece={piece}\n                      onClick={() => handleClick(con)}\n\n                      // onMouseOver={() => handleMouseOver(colorPic)}\n                    />\n                  );\n                })}\n            </div>\n          );\n        })}\n      <h1>{printCheckOutside}</h1>\n      <h1>{printPlayerOutside}</h1>\n    </div>\n  );\n};\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Board />\n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}